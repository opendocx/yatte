{"version":3,"sources":["webpack://yatte/webpack/universalModuleDefinition","webpack://yatte/webpack/bootstrap","webpack://yatte/../number-to-words/numberToWords.min.js","webpack://yatte/./node_modules/angular-expressions/lib/main.js","webpack://yatte/./node_modules/angular-expressions/lib/parse.js","webpack://yatte/./node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js","webpack://yatte/./node_modules/date-fns/difference_in_calendar_days/index.js","webpack://yatte/./node_modules/date-fns/format/index.js","webpack://yatte/./node_modules/date-fns/get_day_of_year/index.js","webpack://yatte/./node_modules/date-fns/get_iso_week/index.js","webpack://yatte/./node_modules/date-fns/get_iso_year/index.js","webpack://yatte/./node_modules/date-fns/is_date/index.js","webpack://yatte/./node_modules/date-fns/is_valid/index.js","webpack://yatte/./node_modules/date-fns/locale/_lib/build_formatting_tokens_reg_exp/index.js","webpack://yatte/./node_modules/date-fns/locale/en/build_distance_in_words_locale/index.js","webpack://yatte/./node_modules/date-fns/locale/en/build_format_locale/index.js","webpack://yatte/./node_modules/date-fns/locale/en/index.js","webpack://yatte/./node_modules/date-fns/parse/index.js","webpack://yatte/./node_modules/date-fns/start_of_day/index.js","webpack://yatte/./node_modules/date-fns/start_of_iso_week/index.js","webpack://yatte/./node_modules/date-fns/start_of_iso_year/index.js","webpack://yatte/./node_modules/date-fns/start_of_week/index.js","webpack://yatte/./node_modules/date-fns/start_of_year/index.js","webpack://yatte/./node_modules/fast-deep-equal/index.js","webpack://yatte/./node_modules/node-libs-browser/node_modules/punycode/punycode.js","webpack://yatte/./node_modules/numeral/numeral.js","webpack://yatte/./node_modules/querystring-es3/decode.js","webpack://yatte/./node_modules/querystring-es3/encode.js","webpack://yatte/./node_modules/querystring-es3/index.js","webpack://yatte/./node_modules/url/url.js","webpack://yatte/./node_modules/url/util.js","webpack://yatte/(webpack)/buildin/global.js","webpack://yatte/(webpack)/buildin/module.js","webpack://yatte/./src/base-templater.js","webpack://yatte/./src/estree.js","webpack://yatte/./src/eval-result.js","webpack://yatte/./src/fieldtypes.js","webpack://yatte/./src/filters.js","webpack://yatte/./src/index.js","webpack://yatte/./src/meta-evaluator.js","webpack://yatte/./src/scope.js","webpack://yatte/./src/text-evaluator.js","webpack://yatte/./src/text-templater.js"],"names":["e","self","global","t","f","l","Math","abs","n","r","o","i","s","zero","one","two","three","four","five","six","seven","eight","nine","ten","eleven","twelve","h","test","replace","a","u","d","v","p","b","y","g","c","m","w","x","parseInt","TypeError","RangeError","arguments","join","push","floor","M","toOrdinal","String","charAt","length","toWords","toWordsOrdinal","module","exports","numberToWords","expressions","require","OD","AST","astMutateInPlace","escapeQuotes","unEscapeQuotes","serializeAST","serialize","parseContentArray","contentArray","bIncludeExpressions","bIncludeListPunctuation","astBody","parsedContentItem","parseContentItem","parsedContent","type","EndList","EndIf","Else","ElseIf","Error","id","Array","prototype","apply","buildLogicTree","copy","reduceContentArray","simplifyContentArray2","simplifyContentArray3","compileExpr","expr","cache","cacheKey","result","undefined","compile","SyntaxError","angularExpressionErrorMessage","ast","body","reduceAstNode","expression","modified","fixFilters","normalizedExpr","existingAst","normalized","fixConditionalExpressions","errLines","message","split","startsWith","errUrl","URL","token","searchParams","get","msg","position","repeat","substr","trim","errInfo","match","idx","contentItem","parsedItems","isArray","parsedBlockContent","parseField","contentArrayItem","content","fieldId","getFieldContent","node","_ifRE","exec","createNode","If","parseFieldExpr","parseContentUntilMatch","_elseifRE","_elseRE","_endifRE","_listRE","List","_endlistRE","Content","newNode","fieldObj","expectarray","compiledExpr","exprAst","startIdx","targetType","originId","parentContent","elseEncountered","isObj","injectListPunctuationNode","forEach","pc","splice","puncNode","priorNode","ix","bInsert","includes","before","slice","after","_curlyquotes","_zws","text","newBody","scope","parentScope","obj","newObj","reduceContentNode","astNode","copyOfNode","existingListNode","pscope","childContext","Object","create","simplifyNode2","initialScope","field","nodeRemoved","toWatch","watchId","simplified","prop","thisArray","ConditionalExpression","fixed","swap","alternate","consequent","CallExpression","filter","convertCallNodeToFilterNode","rtl","getRTLFilterChain","input","innerNode","inputNode","newInnerNode","ListFilterExpression","constant","callee","shift","name","isNormalizedListFilterNode","parsedArg","value","AngularFilterExpression","thisTo$locals","preserve","ThisExpression","LocalsExpression","args","Literal","console","log","Identifier","Program","ExpressionStatement","BlockStatement","EmptyStatement","IfStatement","ForOfStatement","ArrayExpression","ObjectExpression","Property","UnaryExpression","BinaryExpression","LogicalExpression","MemberExpression","serializeAstNode","OPERATOR_PRECEDENCE","NEEDS_PARENTHESES","EXPRESSIONS_PRECEDENCE","mutator","nodeModified","reduce","accumulator","statementObj","object","property","argObj","elements","elem","properties","key","left","right","argument","getExpressionPrecedence","expressionNeedsParentheses","parentNode","isRightHand","nodePrecedence","parentNodePrecedence","operator","serializeOptionallyWrapped","maxPrecedence","orEqual","wrap","serializeBinaryExpressionPart","map","statement","toString","computed","str","arg","prefix","EvaluationResult","missing","errors","valueOf","isDef","val","FT","format","numeral","numWords","Scope","deepEqual","filters","upper","toUpperCase","lower","toLowerCase","initcap","forceLower","titlecaps","generalFmt","negativeFmt","zeroFmt","Date","Boolean","num","Number","fmtStr","cardinal","ordinal","ordsuffix","unansweredFmt","contains","isIterable","item","punc","inputList","example","p1","indexOf","p2","p3","between","last2","only2","trimRight","suffix","sort","sortBy","descending","evaluator","compare","depth","valA","valB","predicateStr","callArrayFunc","find","any","some","every","all","mappedStr","group","groupStr","bucket","_key","_values","func","array","lScope","pushList","__scope","call","index","pushListItem","subResult","_getScopeObject","pop","textTemplater","TextEvaluator","MetaEvaluator","base","Engine","compiledTemplateCache","Map","extractLogic","template","parseTemplate","compileText","context","locals","assemble","set","assembleText","err","assembleMeta","metaTemplate","nodes","program","error","FieldTypes","contextStack","pushObject","ContentReplacementTransform","FlatSingle","frame","_deferredEvaluation","CreateContextErrorMessage","iterable","_evaluate","allContent","_indices","listItemContent","listContentItem","bValue","_scopeType","OBJECT","isTruthy","conditionalContentItem","elseCond","arr","concat","scopeChainHandler","target","current","_data","_parent","_parentScope","scopeType","scopeLabel","data","parent","_label","_dataType","Symbol","toPrimitive","hint","Proxy","empty","label","ListScope","index0","parentList","ItemScope","from","iterator","LIST","indices","_punc","_index0","lastItem","fill","templateCache","hasOwnProperty","tweaked","_blockFieldRE","_blockFieldReplacer","templateSplit","_fieldRE","fieldText","eol","offset","string","cleaned","_fieldsRE","parseText","lines","line","items","lastEnd","end","substring","start","lastIndex","lineArray","lineIndex","itemIndex","ParsedTextTemplate","NormalizeRepeatAndConditional","repeatDepth","conditionalDepth"],"mappings":"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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa;;AAEb,cAAc;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,kCAAkC;AAClC,kCAAkC;;;AAGlC;AACA;AACA;AACA,0CAA0C,mDAAmD;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oDAAoD;AAC9F;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,EAAE;AACb,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,aAAa,aAAa;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,oBAAoB;AAC/B,aAAa;AACb;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;;AAEA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA,IAAI,oBAAoB;AACxB;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA,UAAU,8BAA8B;AACxC;AACA;AACA,UAAU,OAAO;AACjB,UAAU,UAAU;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,cAAc,EAAE,MAAM;AAChD,uBAAuB;AACvB,4BAA4B;AAC5B;AACA;AACA,WAAW,EAAE;AACb,aAAa,EAAE;AACf;AACA,sBAAsB;AACtB;;;AAGA,yBAAyB,4BAA4B;;AAErD;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA,6BAA6B;;;AAG7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA,2BAA2B;;;AAG3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA,0BAA0B;;;AAG1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA,0BAA0B;;;AAG1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA,4BAA4B;;;AAG5B;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;;AAEA;AACA;AACA,aAAa,OAAO,iBAAiB;AACrC;AACA;AACA,cAAc;AACd,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,gBAAgB;AAC3B;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,kBAAkB;AACnE;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,cAAc;AACvC,yBAAyB,cAAc;AACvC,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,WAAW;AACtB,WAAW,KAAK;AAChB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wCAAwC;AACnD,WAAW,eAAe;AAC1B;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,YAAY;AACf;AACA;AACA;AACA;AACA;AACA,4DAA4D,kCAAkC;AAC9F,GAAG;AACH;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,MAAM,4BAA4B;AAClC,WAAW,SAAS;AACpB;AACA;AACA,SAAS,8CAA8C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,wBAAwB;AAC9B;AACA,uCAAuC,4CAA4C;AACnF,uCAAuC,qBAAqB,GAAG,+BAA+B;AAC9F,MAAM,8BAA8B;AACpC,mCAAmC,qCAAqC,gBAAgB,8BAA8B;AACtH;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA,4FAA4F,OAAO;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,GAAG,KAAK,GAAG,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,GAAG,KAAK,GAAG,MAAM;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,MAAM;;AAE1B;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,GAAG,KAAK,GAAG,MAAM;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sCAAsC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA,gFAAgF,4CAA4C;AAC5H,YAAY,qBAAqB,GAAG,+BAA+B,MAAM,8BAA8B;AACvG,iCAAiC,qCAAqC,gBAAgB,8BAA8B;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,8BAA8B;AACzC;AACA;AACA,aAAa;AACb,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD,EAAE;AAC3D,+BAA+B,oBAAoB;AACnD;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2CAA2C;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,EAAE,OAAO,EAAE;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA,8DAA8D,EAAE;AAChE;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,+CAA+C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,sCAAsC;AACtC,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,EAAE,KAAK,EAAE;AAC9C;AACA;AACA;AACA,iCAAiC,EAAE,6BAA6B,EAAE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA,aAAa,+DAA+D;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,KAAK;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA,6CAA6C,yBAAyB;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,wFAAwF,4BAA4B,EAAE;AACtH,cAAc;;;AAGd;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO,2BAA2B,KAAK;AACvC,0BAA0B,4BAA4B;AACtD;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+CAA+C;AAC3E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,gDAAgD,EAAE,WAAW,EAAE,iBAAiB,EAAE;AAClF;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA,yBAAyB;AACzB,gBAAgB;AAChB;AACA;AACA,GAAG;;AAEH;AACA,YAAY;AACZ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK,wBAAwB;AAC7B;AACA,KAAK;AACL;AACA,KAAK;AACL,iBAAiB;AACjB,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,OAAO;AACP,mBAAmB;AACnB;AACA,OAAO;AACP,mBAAmB;AACnB,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;;AAEH;AACA;AACA,YAAY;AACZ,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,YAAY;AACZ,GAAG;;AAEH;AACA;AACA,oCAAoC;AACpC;AACA,wBAAwB;AACxB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,mBAAmB;;AAEnB,YAAY;AACZ,GAAG;;AAEH;AACA;AACA,gCAAgC,EAAE,IAAI,EAAE,YAAY,EAAE,qBAAqB,EAAE,gBAAgB,EAAE;AAC/F;AACA,GAAG;;AAEH;AACA;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,iEAAiE,EAAE;AACnE;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,aAAa,0BAA0B;AACvC,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,sEAAsE,2BAA2B;AAC7G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,WAAW,4BAA4B;AACvC,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qDAAqD;AACrD;AACA;AACA,GAAG;;AAEH;AACA,qCAAqC;AACrC;AACA;AACA,WAAW;AACX,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0DAA0D;AAC1D;AACA,GAAG;;AAEH;AACA,6FAA6F;AAC7F,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,cAAc,EAAE;AAClG;AACA,4CAA4C;AAC5C,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,cAAc,EAAE;AACvF;AACA;AACA;AACA;AACA;AACA,mEAAmE,aAAa,EAAE;AAClF,oEAAoE,cAAc,EAAE;AACpF;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wHAAwH;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,yJAAyJ;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,+CAA+C;AAC/C;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,8CAA8C;AAC9C,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA,gCAAgC;AAChC;AACA,kBAAkB;AAClB;AACA,wBAAwB;AACxB;AACA,oBAAoB;AACpB;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA,4BAA4B,kDAAkD;AAC9E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,WAAW;AACX,SAAS;AACT,qBAAqB;AACrB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,GAAG;AACH;AACA,uBAAuB,mBAAmB,kDAAkD,SAAS;AACrG,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,0BAA0B;AACvC;AACA,sBAAsB,OAAO;AAC7B;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA,yBAAyB,QAAQ;AACjC;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wDAAwD;AACxD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,mDAAmD,QAAQ;AAC3D,6DAA6D;AAC7D;AACA;;AAEA;AACA;;AAEA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;;;;;;;;;;;;;ACn+HA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACpBA,iBAAiB,mBAAO,CAAC,+EAA0B;;AAEnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxCA,mBAAmB,mBAAO,CAAC,qFAA6B;AACxD,iBAAiB,mBAAO,CAAC,+EAA0B;AACnD,iBAAiB,mBAAO,CAAC,+EAA0B;AACnD,YAAY,mBAAO,CAAC,iEAAmB;AACvC,cAAc,mBAAO,CAAC,uEAAsB;AAC5C,eAAe,mBAAO,CAAC,yEAAuB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvUA,YAAY,mBAAO,CAAC,iEAAmB;AACvC,kBAAkB,mBAAO,CAAC,iFAA2B;AACrD,+BAA+B,mBAAO,CAAC,6GAAyC;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC1BA,YAAY,mBAAO,CAAC,iEAAmB;AACvC,qBAAqB,mBAAO,CAAC,yFAA+B;AAC5D,qBAAqB,mBAAO,CAAC,yFAA+B;;AAE5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjCA,YAAY,mBAAO,CAAC,iEAAmB;AACvC,qBAAqB,mBAAO,CAAC,yFAA+B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnBA,aAAa,mBAAO,CAAC,qEAAqB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,aAAa,QAAQ;AACrB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA,0BAA0B,OAAO;AACjC,KAAK;;AAEL;AACA;AACA,gBAAgB,OAAO;AACvB,KAAK;;AAEL;;AAEA;AACA;AACA,0BAA0B,OAAO;AACjC,KAAK;;AAEL;AACA;AACA,gBAAgB,OAAO;AACvB,KAAK;;AAEL;AACA;AACA,sBAAsB,OAAO;AAC7B,KAAK;;AAEL;AACA;AACA,gBAAgB,OAAO;AACvB,KAAK;;AAEL;AACA;AACA,gBAAgB,OAAO;AACvB,KAAK;;AAEL;AACA;AACA,sBAAsB,OAAO;AAC7B,KAAK;;AAEL;AACA;AACA,gBAAgB,OAAO;AACvB,KAAK;;AAEL;AACA;AACA,sBAAsB,OAAO;AAC7B,KAAK;;AAEL;AACA;AACA,gBAAgB,OAAO;AACvB,KAAK;;AAEL;AACA;AACA,qBAAqB,OAAO;AAC5B,KAAK;;AAEL;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,6DAA6D,OAAO;AACpE;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClGA,kCAAkC,mBAAO,CAAC,yIAAqD;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvFA,iCAAiC,mBAAO,CAAC,4HAA2C;AACpF,wBAAwB,mBAAO,CAAC,sGAAgC;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA,sCAAsC,mBAAO,CAAC,+HAAkD;AAChG,aAAa,mBAAO,CAAC,qEAAqB;;AAE1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,EAAE;AAC3B;AACA,YAAY,EAAE;AACd,YAAY,EAAE;AACd,YAAY,EAAE;AACd;;AAEA,2BAA2B,EAAE;AAC7B;AACA,YAAY,EAAE;AACd,YAAY,EAAE;AACd,YAAY,EAAE;AACd;;AAEA;AACA,0BAA0B,EAAE;AAC5B,4BAA4B,EAAE;AAC9B,6BAA6B,EAAE,OAAO,EAAE;AACxC,6BAA6B,EAAE;AAC/B,8BAA8B,EAAE,OAAO,EAAE;;AAEzC;AACA,yBAAyB,EAAE;AAC3B,2BAA2B,EAAE,OAAO,EAAE;AACtC,6BAA6B,EAAE,OAAO,EAAE,OAAO,EAAE;;AAEjD;AACA;AACA;AACA,uCAAuC,EAAE;AACzC,yCAAyC,EAAE,OAAO,EAAE;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3UA,YAAY,mBAAO,CAAC,iEAAmB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACxBA,kBAAkB,mBAAO,CAAC,iFAA2B;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;;AAEA;;;;;;;;;;;;ACxBA,iBAAiB,mBAAO,CAAC,+EAA0B;AACnD,qBAAqB,mBAAO,CAAC,yFAA+B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC/BA,YAAY,mBAAO,CAAC,iEAAmB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACrCA,YAAY,mBAAO,CAAC,iEAAmB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC1Ba;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,WAAW;AAC/B;;AAEA,oBAAoB,WAAW;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;ACtDA;AACA,CAAC;;AAED;AACA,mBAAmB,KAA0B;AAC7C;AACA,kBAAkB,KAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,SAAS;AACrB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,KAAK;AACL,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;;AAExB,yCAAyC,qBAAqB;;AAE9D;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;;AAEtD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAc,iBAAiB;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE,IAEU;AACZ;AACA,EAAE,mCAAmB;AACrB;AACA,GAAG;AAAA,oGAAC;AACJ,EAAE,MAAM,EAaN;;AAEF,CAAC;;;;;;;;;;;;;ACphBD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,IAA0C;AAClD,QAAQ,oCAAO,OAAO;AAAA;AAAA;AAAA;AAAA,oGAAC;AACvB,KAAK,MAAM,EAIN;AACL,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA,yDAAyD,EAAE;AAC3D;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oDAAoD,yDAAyD;AAC7G;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,EAAE;;AAEvD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;;;AAIL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT,CAAC;;;AAGD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,gCAAgC;AAC3D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,YAAY;AACrE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,QAAQ;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,8CAA8C,EAAE;;AAEhD;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA,CAAC;;;;;;;;;;;;;ACp/BD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpFa;;AAEb,iCAAiC,mBAAO,CAAC,0DAAU;AACnD,qCAAqC,mBAAO,CAAC,0DAAU;;;;;;;;;;;;;ACHvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,eAAe,mBAAO,CAAC,oFAAU;AACjC,WAAW,mBAAO,CAAC,0CAAQ;;AAE3B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,KAAK;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,2CAA2C,KAAK;AAChD,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,mBAAO,CAAC,4DAAa;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3tBa;;AAEb;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;ACfA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrBA,IAAM0D,WAAW,GAAGC,mBAAO,CAAC,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","file":"yatte.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"yatte\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"yatte\"] = factory();\n\telse\n\t\troot[\"yatte\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","/*!\n * Number-To-Words util\n * @version v1.2.4\n * @link https://github.com/marlun78/number-to-words\n * @author Martin Eneqvist (https://github.com/marlun78)\n * @contributors Aleksey Pilyugin (https://github.com/pilyugin),Jeremiah Hall (https://github.com/jeremiahrhall),Adriano Melo (https://github.com/adrianomelo),dmrzn (https://github.com/dmrzn)\n * @license MIT\n */\n!function(){\"use strict\";var e=\"object\"==typeof self&&self.self===self&&self||\"object\"==typeof global&&global.global===global&&global||this,t=9007199254740991;function f(e){return!(\"number\"!=typeof e||e!=e||e===1/0||e===-1/0)}function l(e){return\"number\"==typeof e&&Math.abs(e)<=t}var n=/(hundred|thousand|(m|b|tr|quadr)illion)$/,r=/teen$/,o=/y$/,i=/(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve)$/,s={zero:\"zeroth\",one:\"first\",two:\"second\",three:\"third\",four:\"fourth\",five:\"fifth\",six:\"sixth\",seven:\"seventh\",eight:\"eighth\",nine:\"ninth\",ten:\"tenth\",eleven:\"eleventh\",twelve:\"twelfth\"};function h(e){return n.test(e)||r.test(e)?e+\"th\":o.test(e)?e.replace(o,\"ieth\"):i.test(e)?e.replace(i,a):e}function a(e,t){return s[t]}var u=10,d=100,v=1e3,p=1e6,b=1e9,y=1e12,g=1e15,c=9007199254740992,m=[\"zero\",\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\",\"ten\",\"eleven\",\"twelve\",\"thirteen\",\"fourteen\",\"fifteen\",\"sixteen\",\"seventeen\",\"eighteen\",\"nineteen\"],w=[\"zero\",\"ten\",\"twenty\",\"thirty\",\"forty\",\"fifty\",\"sixty\",\"seventy\",\"eighty\",\"ninety\"];function x(e,t){var n,r=parseInt(e,10);if(!f(r))throw new TypeError(\"Not a finite number: \"+e+\" (\"+typeof e+\")\");if(!l(r))throw new RangeError(\"Input is not a safe number; its either too large or too small.\");return n=function e(t){var n,r,o=arguments[1];if(0===t)return o?o.join(\" \"):\"zero\";o||(o=[]);t<0&&(o.push(\"minus\"),t=Math.abs(t));t<20?(n=0,r=m[t]):t<d?(n=t%u,r=w[Math.floor(t/u)],n&&(r+=\"-\"+m[n],n=0)):t<v?(n=t%d,r=e(Math.floor(t/d))+\" hundred\"):t<p?(n=t%v,r=e(Math.floor(t/v))+\" thousand\"):t<b?(n=t%p,r=e(Math.floor(t/p))+\" million\"):t<y?(n=t%b,r=e(Math.floor(t/b))+\" billion\"):t<g?(n=t%y,r=e(Math.floor(t/y))+\" trillion\"):t<=c&&(n=t%g,r=e(Math.floor(t/g))+\" quadrillion\");o.push(r);return e(n,o)}(r),t?h(n):n}var M={toOrdinal:function(e){var t=parseInt(e,10);if(!f(t))throw new TypeError(\"Not a finite number: \"+e+\" (\"+typeof e+\")\");if(!l(t))throw new RangeError(\"Input is not a safe number, its either too large or too small.\");var n=String(t),r=Math.abs(t%100),o=11<=r&&r<=13,i=n.charAt(n.length-1);return n+(o?\"th\":\"1\"===i?\"st\":\"2\"===i?\"nd\":\"3\"===i?\"rd\":\"th\")},toWords:x,toWordsOrdinal:function(e){return h(x(e))}};\"undefined\"!=typeof exports?(\"undefined\"!=typeof module&&module.exports&&(exports=module.exports=M),exports.numberToWords=M):e.numberToWords=M}();","\"use strict\";\n\nvar parse = require(\"./parse.js\");\n\nvar filters = {};\nvar Lexer = parse.Lexer;\nvar Parser = parse.Parser;\nvar parserOptions = {\n    csp: false, // noUnsafeEval,\n    expensiveChecks: true,\n    literals: { // defined at: function $ParseProvider() {\n        true: true,\n        false: false,\n        null: null,\n        /*eslint no-undefined: 0*/\n        undefined: undefined\n        /* eslint: no-undefined: 1  */\n    }\n    //isIdentifierStart: undefined, //isFunction(identStart) && identStart,\n    //isIdentifierContinue: undefined //isFunction(identContinue) && identContinue\n};\n\nvar lexer = new Lexer({});\nvar parser = new Parser(lexer, function getFilter(name) {\n    return filters[name];\n}, parserOptions);\n\n/**\n * Compiles src and returns a function that executes src on a target object.\n * The compiled function is cached under compile.cache[src] to speed up further calls.\n *\n * @param {string} src\n * @returns {function}\n */\nfunction compile(src) {\n    var cached;\n\n    if (typeof src !== \"string\") {\n        throw new TypeError(\"src must be a string, instead saw '\" + typeof src + \"'\");\n    }\n\n    if (!compile.cache) {\n        return parser.parse(src);\n    }\n\n    cached = compile.cache[src];\n    if (!cached) {\n        cached = compile.cache[src] = parser.parse(src);\n    }\n\n    return cached;\n}\n\n/**\n * A cache containing all compiled functions. The src is used as key.\n * Set this on false to disable the cache.\n *\n * @type {object}\n */\ncompile.cache = {};\n\nexports.Lexer = Lexer;\nexports.Parser = Parser;\nexports.compile = compile;\nexports.filters = filters;\n","/* remove eslint errors to see if there is something really wrong */\n/*eslint quotes: [0]*/\n/*eslint indent: [0]*/\n/*eslint vars-on-top: [0]*/\n/*eslint yoda: 0*/\n/*eslint curly: 0*/\n/*eslint no-implicit-coercion: 0*/\n/*eslint newline-after-var: 0*/\n/*eslint space-before-function-paren: 0*/\n/*eslint block-spacing: 0*/\n/*eslint brace-style: 0*/\n/*eslint complexity: 0*/\n/*eslint one-var: 0*/\n/*eslint eqeqeq: 0*/\n/*eslint object-curly-spacing: 0*/\n/*eslint quote-props: 0*/\n/*eslint key-spacing: 0*/\n/*eslint valid-jsdoc: 0*/\n/*eslint func-style: 0*/\n/*eslint no-nested-ternary: 0*/\n/*eslint operator-linebreak: 0*/\n/*eslint no-multi-spaces: 0*/\n/*eslint no-constant-condition: 0*/\n/*eslint comma-spacing: 0*/\n/*eslint no-else-return: 0*/\n/*eslint no-warning-comments: 0*/\n/*eslint default-case: 0*/\n/*eslint consistent-return: 0*/\n/*eslint no-undefined: 0*/\n/*eslint no-new-func: 0*/\n/*eslint max-nested-callbacks: 0*/\n/*eslint padded-blocks: 0*/\n/*eslint no-self-compare: 0*/\n/*eslint no-multiple-empty-lines: 0*/\n/*eslint no-new: 0*/\n/*eslint no-unused-vars: 0*/\n'use strict';\n\nvar window = {document: {}};\n\n'use strict';\n\n/* We need to tell ESLint what variables are being exported */\n/* exported\n  angular,\n  msie,\n  jqLite,\n  jQuery,\n  slice,\n  splice,\n  push,\n  toString,\n  ngMinErr,\n  angularModule,\n  uid,\n  REGEX_STRING_REGEXP,\n  VALIDITY_STATE_PROPERTY,\n\n  lowercase,\n  uppercase,\n  manualLowercase,\n  manualUppercase,\n  nodeName_,\n  isArrayLike,\n  forEach,\n  forEachSorted,\n  reverseParams,\n  nextUid,\n  setHashKey,\n  extend,\n  toInt,\n  inherit,\n  merge,\n  noop,\n  identity,\n  valueFn,\n  isUndefined,\n  isDefined,\n  isObject,\n  isBlankObject,\n  isString,\n  isNumber,\n  isNumberNaN,\n  isDate,\n  isArray,\n  isFunction,\n  isRegExp,\n  isWindow,\n  isScope,\n  isFile,\n  isFormData,\n  isBlob,\n  isBoolean,\n  isPromiseLike,\n  trim,\n  escapeForRegexp,\n  isElement,\n  makeMap,\n  includes,\n  arrayRemove,\n  copy,\n  equals,\n  csp,\n  jq,\n  concat,\n  sliceArgs,\n  bind,\n  toJsonReplacer,\n  toJson,\n  fromJson,\n  convertTimezoneToLocal,\n  timezoneToOffset,\n  startingTag,\n  tryDecodeURIComponent,\n  parseKeyValue,\n  toKeyValue,\n  encodeUriSegment,\n  encodeUriQuery,\n  angularInit,\n  bootstrap,\n  getTestability,\n  snake_case,\n  bindJQuery,\n  assertArg,\n  assertArgFn,\n  assertNotHasOwnProperty,\n  getter,\n  getBlockNodes,\n  hasOwnProperty,\n  createMap,\n  stringify,\n\n  NODE_TYPE_ELEMENT,\n  NODE_TYPE_ATTRIBUTE,\n  NODE_TYPE_TEXT,\n  NODE_TYPE_COMMENT,\n  NODE_TYPE_DOCUMENT,\n  NODE_TYPE_DOCUMENT_FRAGMENT\n*/\n\n////////////////////////////////////\n\n/**\n * @ngdoc module\n * @name ng\n * @module ng\n * @installation\n * @description\n *\n * # ng (core module)\n * The ng module is loaded by default when an AngularJS application is started. The module itself\n * contains the essential components for an AngularJS application to function. The table below\n * lists a high level breakdown of each of the services/factories, filters, directives and testing\n * components available within this core module.\n *\n * <div doc-module-components=\"ng\"></div>\n */\n\nvar REGEX_STRING_REGEXP = /^\\/(.+)\\/([a-z]*)$/;\n\n// The name of a form control's ValidityState property.\n// This is used so that it's possible for internal tests to create mock ValidityStates.\nvar VALIDITY_STATE_PROPERTY = 'validity';\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar lowercase = function(string) {return isString(string) ? string.toLowerCase() : string;};\nvar uppercase = function(string) {return isString(string) ? string.toUpperCase() : string;};\n\n\nvar manualLowercase = function(s) {\n  /* eslint-disable no-bitwise */\n  return isString(s)\n      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})\n      : s;\n  /* eslint-enable */\n};\nvar manualUppercase = function(s) {\n  /* eslint-disable no-bitwise */\n  return isString(s)\n      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})\n      : s;\n  /* eslint-enable */\n};\n\n\n// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish\n// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods\n// with correct but slower alternatives. See https://github.com/angular/angular.js/issues/11387\nif ('i' !== 'I'.toLowerCase()) {\n  lowercase = manualLowercase;\n  uppercase = manualUppercase;\n}\n\n\nvar\n    msie,             // holds major version number for IE, or NaN if UA is not IE.\n    jqLite,           // delay binding since jQuery could be loaded after us.\n    jQuery,           // delay binding\n    slice             = [].slice,\n    splice            = [].splice,\n    push              = [].push,\n    toString          = Object.prototype.toString,\n    getPrototypeOf    = Object.getPrototypeOf,\n    ngMinErr          = minErr('ng'),\n\n    /** @name angular */\n    angular           = window.angular || (window.angular = {}),\n    angularModule,\n    uid               = 0;\n\n/**\n * documentMode is an IE-only property\n * http://msdn.microsoft.com/en-us/library/ie/cc196988(v=vs.85).aspx\n */\nmsie = window.document.documentMode;\n\n\n/**\n * @private\n * @param {*} obj\n * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments,\n *                   String ...)\n */\nfunction isArrayLike(obj) {\n\n  // `null`, `undefined` and `window` are not array-like\n  if (obj == null || isWindow(obj)) return false;\n\n  // arrays, strings and jQuery/jqLite objects are array like\n  // * jqLite is either the jQuery or jqLite constructor function\n  // * we have to check the existence of jqLite first as this method is called\n  //   via the forEach method when constructing the jqLite object in the first place\n  if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite)) return true;\n\n  // Support: iOS 8.2 (not reproducible in simulator)\n  // \"length\" in obj used to prevent JIT error (gh-11508)\n  var length = 'length' in Object(obj) && obj.length;\n\n  // NodeList objects (with `item` method) and\n  // other objects with suitable length characteristics are array-like\n  return isNumber(length) &&\n    (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item === 'function');\n\n}\n\n/**\n * @ngdoc function\n * @name angular.forEach\n * @module ng\n * @kind function\n *\n * @description\n * Invokes the `iterator` function once for each item in `obj` collection, which can be either an\n * object or an array. The `iterator` function is invoked with `iterator(value, key, obj)`, where `value`\n * is the value of an object property or an array element, `key` is the object property key or\n * array element index and obj is the `obj` itself. Specifying a `context` for the function is optional.\n *\n * It is worth noting that `.forEach` does not iterate over inherited properties because it filters\n * using the `hasOwnProperty` method.\n *\n * Unlike ES262's\n * [Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18),\n * providing 'undefined' or 'null' values for `obj` will not throw a TypeError, but rather just\n * return the value provided.\n *\n   ```js\n     var values = {name: 'misko', gender: 'male'};\n     var log = [];\n     angular.forEach(values, function(value, key) {\n       this.push(key + ': ' + value);\n     }, log);\n     expect(log).toEqual(['name: misko', 'gender: male']);\n   ```\n *\n * @param {Object|Array} obj Object to iterate over.\n * @param {Function} iterator Iterator function.\n * @param {Object=} context Object to become context (`this`) for the iterator function.\n * @returns {Object|Array} Reference to `obj`.\n */\n\nfunction forEach(obj, iterator, context) {\n  var key, length;\n  if (obj) {\n    if (isFunction(obj)) {\n      for (key in obj) {\n        if (key !== 'prototype' && key !== 'length' && key !== 'name' && obj.hasOwnProperty(key)) {\n          iterator.call(context, obj[key], key, obj);\n        }\n      }\n    } else if (isArray(obj) || isArrayLike(obj)) {\n      var isPrimitive = typeof obj !== 'object';\n      for (key = 0, length = obj.length; key < length; key++) {\n        if (isPrimitive || key in obj) {\n          iterator.call(context, obj[key], key, obj);\n        }\n      }\n    } else if (obj.forEach && obj.forEach !== forEach) {\n        obj.forEach(iterator, context, obj);\n    } else if (isBlankObject(obj)) {\n      // createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty\n      for (key in obj) {\n        iterator.call(context, obj[key], key, obj);\n      }\n    } else if (typeof obj.hasOwnProperty === 'function') {\n      // Slow path for objects inheriting Object.prototype, hasOwnProperty check needed\n      for (key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          iterator.call(context, obj[key], key, obj);\n        }\n      }\n    } else {\n      // Slow path for objects which do not have a method `hasOwnProperty`\n      for (key in obj) {\n        if (hasOwnProperty.call(obj, key)) {\n          iterator.call(context, obj[key], key, obj);\n        }\n      }\n    }\n  }\n  return obj;\n}\n\nfunction forEachSorted(obj, iterator, context) {\n  var keys = Object.keys(obj).sort();\n  for (var i = 0; i < keys.length; i++) {\n    iterator.call(context, obj[keys[i]], keys[i]);\n  }\n  return keys;\n}\n\n\n/**\n * when using forEach the params are value, key, but it is often useful to have key, value.\n * @param {function(string, *)} iteratorFn\n * @returns {function(*, string)}\n */\nfunction reverseParams(iteratorFn) {\n  return function(value, key) {iteratorFn(key, value);};\n}\n\n/**\n * A consistent way of creating unique IDs in angular.\n *\n * Using simple numbers allows us to generate 28.6 million unique ids per second for 10 years before\n * we hit number precision issues in JavaScript.\n *\n * Math.pow(2,53) / 60 / 60 / 24 / 365 / 10 = 28.6M\n *\n * @returns {number} an unique alpha-numeric string\n */\nfunction nextUid() {\n  return ++uid;\n}\n\n\n/**\n * Set or clear the hashkey for an object.\n * @param obj object\n * @param h the hashkey (!truthy to delete the hashkey)\n */\nfunction setHashKey(obj, h) {\n  if (h) {\n    obj.$$hashKey = h;\n  } else {\n    delete obj.$$hashKey;\n  }\n}\n\n\nfunction baseExtend(dst, objs, deep) {\n  var h = dst.$$hashKey;\n\n  for (var i = 0, ii = objs.length; i < ii; ++i) {\n    var obj = objs[i];\n    if (!isObject(obj) && !isFunction(obj)) continue;\n    var keys = Object.keys(obj);\n    for (var j = 0, jj = keys.length; j < jj; j++) {\n      var key = keys[j];\n      var src = obj[key];\n\n      if (deep && isObject(src)) {\n        if (isDate(src)) {\n          dst[key] = new Date(src.valueOf());\n        } else if (isRegExp(src)) {\n          dst[key] = new RegExp(src);\n        } else if (src.nodeName) {\n          dst[key] = src.cloneNode(true);\n        } else if (isElement(src)) {\n          dst[key] = src.clone();\n        } else {\n          if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};\n          baseExtend(dst[key], [src], true);\n        }\n      } else {\n        dst[key] = src;\n      }\n    }\n  }\n\n  setHashKey(dst, h);\n  return dst;\n}\n\n/**\n * @ngdoc function\n * @name angular.extend\n * @module ng\n * @kind function\n *\n * @description\n * Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)\n * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so\n * by passing an empty object as the target: `var object = angular.extend({}, object1, object2)`.\n *\n * **Note:** Keep in mind that `angular.extend` does not support recursive merge (deep copy). Use\n * {@link angular.merge} for this.\n *\n * @param {Object} dst Destination object.\n * @param {...Object} src Source object(s).\n * @returns {Object} Reference to `dst`.\n */\nfunction extend(dst) {\n  return baseExtend(dst, slice.call(arguments, 1), false);\n}\n\n\n/**\n* @ngdoc function\n* @name angular.merge\n* @module ng\n* @kind function\n*\n* @description\n* Deeply extends the destination object `dst` by copying own enumerable properties from the `src` object(s)\n* to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so\n* by passing an empty object as the target: `var object = angular.merge({}, object1, object2)`.\n*\n* Unlike {@link angular.extend extend()}, `merge()` recursively descends into object properties of source\n* objects, performing a deep copy.\n*\n* @param {Object} dst Destination object.\n* @param {...Object} src Source object(s).\n* @returns {Object} Reference to `dst`.\n*/\nfunction merge(dst) {\n  return baseExtend(dst, slice.call(arguments, 1), true);\n}\n\n\n\nfunction toInt(str) {\n  return parseInt(str, 10);\n}\n\nvar isNumberNaN = Number.isNaN || function isNumberNaN(num) {\n  // eslint-disable-next-line no-self-compare\n  return num !== num;\n};\n\n\nfunction inherit(parent, extra) {\n  return extend(Object.create(parent), extra);\n}\n\n/**\n * @ngdoc function\n * @name angular.noop\n * @module ng\n * @kind function\n *\n * @description\n * A function that performs no operations. This function can be useful when writing code in the\n * functional style.\n   ```js\n     function foo(callback) {\n       var result = calculateResult();\n       (callback || angular.noop)(result);\n     }\n   ```\n */\nfunction noop() {}\nnoop.$inject = [];\n\n\n/**\n * @ngdoc function\n * @name angular.identity\n * @module ng\n * @kind function\n *\n * @description\n * A function that returns its first argument. This function is useful when writing code in the\n * functional style.\n *\n   ```js\n   function transformer(transformationFn, value) {\n     return (transformationFn || angular.identity)(value);\n   };\n\n   // E.g.\n   function getResult(fn, input) {\n     return (fn || angular.identity)(input);\n   };\n\n   getResult(function(n) { return n * 2; }, 21);   // returns 42\n   getResult(null, 21);                            // returns 21\n   getResult(undefined, 21);                       // returns 21\n   ```\n *\n * @param {*} value to be returned.\n * @returns {*} the value passed in.\n */\nfunction identity($) {return $;}\nidentity.$inject = [];\n\n\nfunction valueFn(value) {return function valueRef() {return value;};}\n\nfunction hasCustomToString(obj) {\n  return isFunction(obj.toString) && obj.toString !== toString;\n}\n\n\n/**\n * @ngdoc function\n * @name angular.isUndefined\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is undefined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is undefined.\n */\nfunction isUndefined(value) {return typeof value === 'undefined';}\n\n\n/**\n * @ngdoc function\n * @name angular.isDefined\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is defined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is defined.\n */\nfunction isDefined(value) {return typeof value !== 'undefined';}\n\n\n/**\n * @ngdoc function\n * @name angular.isObject\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not\n * considered to be objects. Note that JavaScript arrays are objects.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Object` but not `null`.\n */\nfunction isObject(value) {\n  // http://jsperf.com/isobject4\n  return value !== null && typeof value === 'object';\n}\n\n\n/**\n * Determine if a value is an object with a null prototype\n *\n * @returns {boolean} True if `value` is an `Object` with a null prototype\n */\nfunction isBlankObject(value) {\n  return value !== null && typeof value === 'object' && !getPrototypeOf(value);\n}\n\n\n/**\n * @ngdoc function\n * @name angular.isString\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `String`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `String`.\n */\nfunction isString(value) {return typeof value === 'string';}\n\n\n/**\n * @ngdoc function\n * @name angular.isNumber\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `Number`.\n *\n * This includes the \"special\" numbers `NaN`, `+Infinity` and `-Infinity`.\n *\n * If you wish to exclude these then you can use the native\n * [`isFinite'](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)\n * method.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Number`.\n */\nfunction isNumber(value) {return typeof value === 'number';}\n\n\n/**\n * @ngdoc function\n * @name angular.isDate\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a value is a date.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Date`.\n */\nfunction isDate(value) {\n  return toString.call(value) === '[object Date]';\n}\n\n\n/**\n * @ngdoc function\n * @name angular.isArray\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is an `Array`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Array`.\n */\nvar isArray = Array.isArray;\n\n/**\n * @ngdoc function\n * @name angular.isFunction\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a `Function`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Function`.\n */\nfunction isFunction(value) {return typeof value === 'function';}\n\n\n/**\n * Determines if a value is a regular expression object.\n *\n * @private\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `RegExp`.\n */\nfunction isRegExp(value) {\n  return toString.call(value) === '[object RegExp]';\n}\n\n\n/**\n * Checks if `obj` is a window object.\n *\n * @private\n * @param {*} obj Object to check\n * @returns {boolean} True if `obj` is a window obj.\n */\nfunction isWindow(obj) {\n  return obj && obj.window === obj;\n}\n\n\nfunction isScope(obj) {\n  return obj && obj.$evalAsync && obj.$watch;\n}\n\n\nfunction isFile(obj) {\n  return toString.call(obj) === '[object File]';\n}\n\n\nfunction isFormData(obj) {\n  return toString.call(obj) === '[object FormData]';\n}\n\n\nfunction isBlob(obj) {\n  return toString.call(obj) === '[object Blob]';\n}\n\n\nfunction isBoolean(value) {\n  return typeof value === 'boolean';\n}\n\n\nfunction isPromiseLike(obj) {\n  return obj && isFunction(obj.then);\n}\n\n\nvar TYPED_ARRAY_REGEXP = /^\\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\\]$/;\nfunction isTypedArray(value) {\n  return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));\n}\n\nfunction isArrayBuffer(obj) {\n  return toString.call(obj) === '[object ArrayBuffer]';\n}\n\n\nvar trim = function(value) {\n  return isString(value) ? value.trim() : value;\n};\n\n// Copied from:\n// http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021\n// Prereq: s is a string.\nvar escapeForRegexp = function(s) {\n  return s\n    .replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1')\n    // eslint-disable-next-line no-control-regex\n    .replace(/\\x08/g, '\\\\x08');\n};\n\n\n/**\n * @ngdoc function\n * @name angular.isElement\n * @module ng\n * @kind function\n *\n * @description\n * Determines if a reference is a DOM element (or wrapped jQuery element).\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).\n */\nfunction isElement(node) {\n  return !!(node &&\n    (node.nodeName  // We are a direct element.\n    || (node.prop && node.attr && node.find)));  // We have an on and find method part of jQuery API.\n}\n\n/**\n * @param str 'key1,key2,...'\n * @returns {object} in the form of {key1:true, key2:true, ...}\n */\nfunction makeMap(str) {\n  var obj = {}, items = str.split(','), i;\n  for (i = 0; i < items.length; i++) {\n    obj[items[i]] = true;\n  }\n  return obj;\n}\n\n\nfunction nodeName_(element) {\n  return lowercase(element.nodeName || (element[0] && element[0].nodeName));\n}\n\nfunction includes(array, obj) {\n  return Array.prototype.indexOf.call(array, obj) !== -1;\n}\n\nfunction arrayRemove(array, value) {\n  var index = array.indexOf(value);\n  if (index >= 0) {\n    array.splice(index, 1);\n  }\n  return index;\n}\n\n/**\n * @ngdoc function\n * @name angular.copy\n * @module ng\n * @kind function\n *\n * @description\n * Creates a deep copy of `source`, which should be an object or an array.\n *\n * * If no destination is supplied, a copy of the object or array is created.\n * * If a destination is provided, all of its elements (for arrays) or properties (for objects)\n *   are deleted and then all elements/properties from the source are copied to it.\n * * If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.\n * * If `source` is identical to `destination` an exception will be thrown.\n *\n * <br />\n * <div class=\"alert alert-warning\">\n *   Only enumerable properties are taken into account. Non-enumerable properties (both on `source`\n *   and on `destination`) will be ignored.\n * </div>\n *\n * @param {*} source The source that will be used to make a copy.\n *                   Can be any type, including primitives, `null`, and `undefined`.\n * @param {(Object|Array)=} destination Destination into which the source is copied. If\n *     provided, must be of the same type as `source`.\n * @returns {*} The copy or updated `destination`, if `destination` was specified.\n *\n * @example\n  <example module=\"copyExample\" name=\"angular-copy\">\n    <file name=\"index.html\">\n      <div ng-controller=\"ExampleController\">\n        <form novalidate class=\"simple-form\">\n          <label>Name: <input type=\"text\" ng-model=\"user.name\" /></label><br />\n          <label>Age:  <input type=\"number\" ng-model=\"user.age\" /></label><br />\n          Gender: <label><input type=\"radio\" ng-model=\"user.gender\" value=\"male\" />male</label>\n                  <label><input type=\"radio\" ng-model=\"user.gender\" value=\"female\" />female</label><br />\n          <button ng-click=\"reset()\">RESET</button>\n          <button ng-click=\"update(user)\">SAVE</button>\n        </form>\n        <pre>form = {{user | json}}</pre>\n        <pre>master = {{master | json}}</pre>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      // Module: copyExample\n      angular.\n        module('copyExample', []).\n        controller('ExampleController', ['$scope', function($scope) {\n          $scope.master = {};\n\n          $scope.reset = function() {\n            // Example with 1 argument\n            $scope.user = angular.copy($scope.master);\n          };\n\n          $scope.update = function(user) {\n            // Example with 2 arguments\n            angular.copy(user, $scope.master);\n          };\n\n          $scope.reset();\n        }]);\n    </file>\n  </example>\n */\nfunction copy(source, destination) {\n  var stackSource = [];\n  var stackDest = [];\n\n  if (destination) {\n    if (isTypedArray(destination) || isArrayBuffer(destination)) {\n      throw ngMinErr('cpta', 'Can\\'t copy! TypedArray destination cannot be mutated.');\n    }\n    if (source === destination) {\n      throw ngMinErr('cpi', 'Can\\'t copy! Source and destination are identical.');\n    }\n\n    // Empty the destination object\n    if (isArray(destination)) {\n      destination.length = 0;\n    } else {\n      forEach(destination, function(value, key) {\n        if (key !== '$$hashKey') {\n          delete destination[key];\n        }\n      });\n    }\n\n    stackSource.push(source);\n    stackDest.push(destination);\n    return copyRecurse(source, destination);\n  }\n\n  return copyElement(source);\n\n  function copyRecurse(source, destination) {\n    var h = destination.$$hashKey;\n    var key;\n    if (isArray(source)) {\n      for (var i = 0, ii = source.length; i < ii; i++) {\n        destination.push(copyElement(source[i]));\n      }\n    } else if (isBlankObject(source)) {\n      // createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty\n      for (key in source) {\n        destination[key] = copyElement(source[key]);\n      }\n    } else if (source && typeof source.hasOwnProperty === 'function') {\n      // Slow path, which must rely on hasOwnProperty\n      for (key in source) {\n        if (source.hasOwnProperty(key)) {\n          destination[key] = copyElement(source[key]);\n        }\n      }\n    } else {\n      // Slowest path --- hasOwnProperty can't be called as a method\n      for (key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          destination[key] = copyElement(source[key]);\n        }\n      }\n    }\n    setHashKey(destination, h);\n    return destination;\n  }\n\n  function copyElement(source) {\n    // Simple values\n    if (!isObject(source)) {\n      return source;\n    }\n\n    // Already copied values\n    var index = stackSource.indexOf(source);\n    if (index !== -1) {\n      return stackDest[index];\n    }\n\n    if (isWindow(source) || isScope(source)) {\n      throw ngMinErr('cpws',\n        'Can\\'t copy! Making copies of Window or Scope instances is not supported.');\n    }\n\n    var needsRecurse = false;\n    var destination = copyType(source);\n\n    if (destination === undefined) {\n      destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));\n      needsRecurse = true;\n    }\n\n    stackSource.push(source);\n    stackDest.push(destination);\n\n    return needsRecurse\n      ? copyRecurse(source, destination)\n      : destination;\n  }\n\n  function copyType(source) {\n    switch (toString.call(source)) {\n      case '[object Int8Array]':\n      case '[object Int16Array]':\n      case '[object Int32Array]':\n      case '[object Float32Array]':\n      case '[object Float64Array]':\n      case '[object Uint8Array]':\n      case '[object Uint8ClampedArray]':\n      case '[object Uint16Array]':\n      case '[object Uint32Array]':\n        return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);\n\n      case '[object ArrayBuffer]':\n        // Support: IE10\n        if (!source.slice) {\n          // If we're in this case we know the environment supports ArrayBuffer\n          /* eslint-disable no-undef */\n          var copied = new ArrayBuffer(source.byteLength);\n          new Uint8Array(copied).set(new Uint8Array(source));\n          /* eslint-enable */\n          return copied;\n        }\n        return source.slice(0);\n\n      case '[object Boolean]':\n      case '[object Number]':\n      case '[object String]':\n      case '[object Date]':\n        return new source.constructor(source.valueOf());\n\n      case '[object RegExp]':\n        var re = new RegExp(source.source, source.toString().match(/[^\\/]*$/)[0]);\n        re.lastIndex = source.lastIndex;\n        return re;\n\n      case '[object Blob]':\n        return new source.constructor([source], {type: source.type});\n    }\n\n    if (isFunction(source.cloneNode)) {\n      return source.cloneNode(true);\n    }\n  }\n}\n\n\n/**\n * @ngdoc function\n * @name angular.equals\n * @module ng\n * @kind function\n *\n * @description\n * Determines if two objects or two values are equivalent. Supports value types, regular\n * expressions, arrays and objects.\n *\n * Two objects or values are considered equivalent if at least one of the following is true:\n *\n * * Both objects or values pass `===` comparison.\n * * Both objects or values are of the same type and all of their properties are equal by\n *   comparing them with `angular.equals`.\n * * Both values are NaN. (In JavaScript, NaN == NaN => false. But we consider two NaN as equal)\n * * Both values represent the same regular expression (In JavaScript,\n *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual\n *   representation matches).\n *\n * During a property comparison, properties of `function` type and properties with names\n * that begin with `$` are ignored.\n *\n * Scope and DOMWindow objects are being compared only by identify (`===`).\n *\n * @param {*} o1 Object or value to compare.\n * @param {*} o2 Object or value to compare.\n * @returns {boolean} True if arguments are equal.\n *\n * @example\n   <example module=\"equalsExample\" name=\"equalsExample\">\n     <file name=\"index.html\">\n      <div ng-controller=\"ExampleController\">\n        <form novalidate>\n          <h3>User 1</h3>\n          Name: <input type=\"text\" ng-model=\"user1.name\">\n          Age: <input type=\"number\" ng-model=\"user1.age\">\n\n          <h3>User 2</h3>\n          Name: <input type=\"text\" ng-model=\"user2.name\">\n          Age: <input type=\"number\" ng-model=\"user2.age\">\n\n          <div>\n            <br/>\n            <input type=\"button\" value=\"Compare\" ng-click=\"compare()\">\n          </div>\n          User 1: <pre>{{user1 | json}}</pre>\n          User 2: <pre>{{user2 | json}}</pre>\n          Equal: <pre>{{result}}</pre>\n        </form>\n      </div>\n    </file>\n    <file name=\"script.js\">\n        angular.module('equalsExample', []).controller('ExampleController', ['$scope', function($scope) {\n          $scope.user1 = {};\n          $scope.user2 = {};\n          $scope.compare = function() {\n            $scope.result = angular.equals($scope.user1, $scope.user2);\n          };\n        }]);\n    </file>\n  </example>\n */\nfunction equals(o1, o2) {\n  if (o1 === o2) return true;\n  if (o1 === null || o2 === null) return false;\n  // eslint-disable-next-line no-self-compare\n  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN\n  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;\n  if (t1 === t2 && t1 === 'object') {\n    if (isArray(o1)) {\n      if (!isArray(o2)) return false;\n      if ((length = o1.length) === o2.length) {\n        for (key = 0; key < length; key++) {\n          if (!equals(o1[key], o2[key])) return false;\n        }\n        return true;\n      }\n    } else if (isDate(o1)) {\n      if (!isDate(o2)) return false;\n      return equals(o1.getTime(), o2.getTime());\n    } else if (isRegExp(o1)) {\n      if (!isRegExp(o2)) return false;\n      return o1.toString() === o2.toString();\n    } else {\n      if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) ||\n        isArray(o2) || isDate(o2) || isRegExp(o2)) return false;\n      keySet = createMap();\n      for (key in o1) {\n        if (key.charAt(0) === '$' || isFunction(o1[key])) continue;\n        if (!equals(o1[key], o2[key])) return false;\n        keySet[key] = true;\n      }\n      for (key in o2) {\n        if (!(key in keySet) &&\n            key.charAt(0) !== '$' &&\n            isDefined(o2[key]) &&\n            !isFunction(o2[key])) return false;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nvar csp = function() {\n  if (!isDefined(csp.rules)) {\n\n\n    var ngCspElement = (window.document.querySelector('[ng-csp]') ||\n                    window.document.querySelector('[data-ng-csp]'));\n\n    if (ngCspElement) {\n      var ngCspAttribute = ngCspElement.getAttribute('ng-csp') ||\n                    ngCspElement.getAttribute('data-ng-csp');\n      csp.rules = {\n        noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),\n        noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)\n      };\n    } else {\n      csp.rules = {\n        noUnsafeEval: noUnsafeEval(),\n        noInlineStyle: false\n      };\n    }\n  }\n\n  return csp.rules;\n\n  function noUnsafeEval() {\n    try {\n      // eslint-disable-next-line no-new, no-new-func\n      new Function('');\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n};\n\n/**\n * @ngdoc directive\n * @module ng\n * @name ngJq\n *\n * @element ANY\n * @param {string=} ngJq the name of the library available under `window`\n * to be used for angular.element\n * @description\n * Use this directive to force the angular.element library.  This should be\n * used to force either jqLite by leaving ng-jq blank or setting the name of\n * the jquery variable under window (eg. jQuery).\n *\n * Since angular looks for this directive when it is loaded (doesn't wait for the\n * DOMContentLoaded event), it must be placed on an element that comes before the script\n * which loads angular. Also, only the first instance of `ng-jq` will be used and all\n * others ignored.\n *\n * @example\n * This example shows how to force jqLite using the `ngJq` directive to the `html` tag.\n ```html\n <!doctype html>\n <html ng-app ng-jq>\n ...\n ...\n </html>\n ```\n * @example\n * This example shows how to use a jQuery based library of a different name.\n * The library name must be available at the top most 'window'.\n ```html\n <!doctype html>\n <html ng-app ng-jq=\"jQueryLib\">\n ...\n ...\n </html>\n ```\n */\nvar jq = function() {\n  if (isDefined(jq.name_)) return jq.name_;\n  var el;\n  var i, ii = ngAttrPrefixes.length, prefix, name;\n  for (i = 0; i < ii; ++i) {\n    prefix = ngAttrPrefixes[i];\n    el = window.document.querySelector('[' + prefix.replace(':', '\\\\:') + 'jq]');\n    if (el) {\n      name = el.getAttribute(prefix + 'jq');\n      break;\n    }\n  }\n\n  return (jq.name_ = name);\n};\n\nfunction concat(array1, array2, index) {\n  return array1.concat(slice.call(array2, index));\n}\n\nfunction sliceArgs(args, startIndex) {\n  return slice.call(args, startIndex || 0);\n}\n\n\n/**\n * @ngdoc function\n * @name angular.bind\n * @module ng\n * @kind function\n *\n * @description\n * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for\n * `fn`). You can supply optional `args` that are prebound to the function. This feature is also\n * known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as\n * distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).\n *\n * @param {Object} self Context which `fn` should be evaluated in.\n * @param {function()} fn Function to be bound.\n * @param {...*} args Optional arguments to be prebound to the `fn` function call.\n * @returns {function()} Function that wraps the `fn` with all the specified bindings.\n */\nfunction bind(self, fn) {\n  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];\n  if (isFunction(fn) && !(fn instanceof RegExp)) {\n    return curryArgs.length\n      ? function() {\n          return arguments.length\n            ? fn.apply(self, concat(curryArgs, arguments, 0))\n            : fn.apply(self, curryArgs);\n        }\n      : function() {\n          return arguments.length\n            ? fn.apply(self, arguments)\n            : fn.call(self);\n        };\n  } else {\n    // In IE, native methods are not functions so they cannot be bound (note: they don't need to be).\n    return fn;\n  }\n}\n\n\nfunction toJsonReplacer(key, value) {\n  var val = value;\n\n  if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {\n    val = undefined;\n  } else if (isWindow(value)) {\n    val = '$WINDOW';\n  } else if (value &&  window.document === value) {\n    val = '$DOCUMENT';\n  } else if (isScope(value)) {\n    val = '$SCOPE';\n  }\n\n  return val;\n}\n\n\n/**\n * @ngdoc function\n * @name angular.toJson\n * @module ng\n * @kind function\n *\n * @description\n * Serializes input into a JSON-formatted string. Properties with leading $$ characters will be\n * stripped since angular uses this notation internally.\n *\n * @param {Object|Array|Date|string|number|boolean} obj Input to be serialized into JSON.\n * @param {boolean|number} [pretty=2] If set to true, the JSON output will contain newlines and whitespace.\n *    If set to an integer, the JSON output will contain that many spaces per indentation.\n * @returns {string|undefined} JSON-ified string representing `obj`.\n * @knownIssue\n *\n * The Safari browser throws a `RangeError` instead of returning `null` when it tries to stringify a `Date`\n * object with an invalid date value. The only reliable way to prevent this is to monkeypatch the\n * `Date.prototype.toJSON` method as follows:\n *\n * ```\n * var _DatetoJSON = Date.prototype.toJSON;\n * Date.prototype.toJSON = function() {\n *   try {\n *     return _DatetoJSON.call(this);\n *   } catch(e) {\n *     if (e instanceof RangeError) {\n *       return null;\n *     }\n *     throw e;\n *   }\n * };\n * ```\n *\n * See https://github.com/angular/angular.js/pull/14221 for more information.\n */\nfunction toJson(obj, pretty) {\n  if (isUndefined(obj)) return undefined;\n  if (!isNumber(pretty)) {\n    pretty = pretty ? 2 : null;\n  }\n  return JSON.stringify(obj, toJsonReplacer, pretty);\n}\n\n\n/**\n * @ngdoc function\n * @name angular.fromJson\n * @module ng\n * @kind function\n *\n * @description\n * Deserializes a JSON string.\n *\n * @param {string} json JSON string to deserialize.\n * @returns {Object|Array|string|number} Deserialized JSON string.\n */\nfunction fromJson(json) {\n  return isString(json)\n      ? JSON.parse(json)\n      : json;\n}\n\n\nvar ALL_COLONS = /:/g;\nfunction timezoneToOffset(timezone, fallback) {\n  // IE/Edge do not \"understand\" colon (`:`) in timezone\n  timezone = timezone.replace(ALL_COLONS, '');\n  var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;\n  return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\n}\n\n\nfunction addDateMinutes(date, minutes) {\n  date = new Date(date.getTime());\n  date.setMinutes(date.getMinutes() + minutes);\n  return date;\n}\n\n\nfunction convertTimezoneToLocal(date, timezone, reverse) {\n  reverse = reverse ? -1 : 1;\n  var dateTimezoneOffset = date.getTimezoneOffset();\n  var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);\n  return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));\n}\n\n\n/**\n * @returns {string} Returns the string representation of the element.\n */\nfunction startingTag(element) {\n  element = jqLite(element).clone();\n  try {\n    // turns out IE does not let you set .html() on elements which\n    // are not allowed to have children. So we just ignore it.\n    element.empty();\n  } catch (e) { /* empty */ }\n  var elemHtml = jqLite('<div>').append(element).html();\n  try {\n    return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) :\n        elemHtml.\n          match(/^(<[^>]+>)/)[1].\n          replace(/^<([\\w\\-]+)/, function(match, nodeName) {return '<' + lowercase(nodeName);});\n  } catch (e) {\n    return lowercase(elemHtml);\n  }\n\n}\n\n\n/////////////////////////////////////////////////\n\n/**\n * Tries to decode the URI component without throwing an exception.\n *\n * @private\n * @param str value potential URI component to check.\n * @returns {boolean} True if `value` can be decoded\n * with the decodeURIComponent function.\n */\nfunction tryDecodeURIComponent(value) {\n  try {\n    return decodeURIComponent(value);\n  } catch (e) {\n    // Ignore any invalid uri component.\n  }\n}\n\n\n/**\n * Parses an escaped url query string into key-value pairs.\n * @returns {Object.<string,boolean|Array>}\n */\nfunction parseKeyValue(/**string*/keyValue) {\n  var obj = {};\n  forEach((keyValue || '').split('&'), function(keyValue) {\n    var splitPoint, key, val;\n    if (keyValue) {\n      key = keyValue = keyValue.replace(/\\+/g,'%20');\n      splitPoint = keyValue.indexOf('=');\n      if (splitPoint !== -1) {\n        key = keyValue.substring(0, splitPoint);\n        val = keyValue.substring(splitPoint + 1);\n      }\n      key = tryDecodeURIComponent(key);\n      if (isDefined(key)) {\n        val = isDefined(val) ? tryDecodeURIComponent(val) : true;\n        if (!hasOwnProperty.call(obj, key)) {\n          obj[key] = val;\n        } else if (isArray(obj[key])) {\n          obj[key].push(val);\n        } else {\n          obj[key] = [obj[key],val];\n        }\n      }\n    }\n  });\n  return obj;\n}\n\nfunction toKeyValue(obj) {\n  var parts = [];\n  forEach(obj, function(value, key) {\n    if (isArray(value)) {\n      forEach(value, function(arrayValue) {\n        parts.push(encodeUriQuery(key, true) +\n                   (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));\n      });\n    } else {\n    parts.push(encodeUriQuery(key, true) +\n               (value === true ? '' : '=' + encodeUriQuery(value, true)));\n    }\n  });\n  return parts.length ? parts.join('&') : '';\n}\n\n\n/**\n * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\n * segments:\n *    segment       = *pchar\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\nfunction encodeUriSegment(val) {\n  return encodeUriQuery(val, true).\n             replace(/%26/gi, '&').\n             replace(/%3D/gi, '=').\n             replace(/%2B/gi, '+');\n}\n\n\n/**\n * This method is intended for encoding *key* or *value* parts of query component. We need a custom\n * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be\n * encoded per http://tools.ietf.org/html/rfc3986:\n *    query         = *( pchar / \"/\" / \"?\" )\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\nfunction encodeUriQuery(val, pctEncodeSpaces) {\n  return encodeURIComponent(val).\n             replace(/%40/gi, '@').\n             replace(/%3A/gi, ':').\n             replace(/%24/g, '$').\n             replace(/%2C/gi, ',').\n             replace(/%3B/gi, ';').\n             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n}\n\nvar ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];\n\nfunction getNgAttribute(element, ngAttr) {\n  var attr, i, ii = ngAttrPrefixes.length;\n  for (i = 0; i < ii; ++i) {\n    attr = ngAttrPrefixes[i] + ngAttr;\n    if (isString(attr = element.getAttribute(attr))) {\n      return attr;\n    }\n  }\n  return null;\n}\n\nfunction allowAutoBootstrap(document) {\n  if (!document.currentScript) {\n    return true;\n  }\n  var src = document.currentScript.getAttribute('src');\n  var link = document.createElement('a');\n  link.href = src;\n  var scriptProtocol = link.protocol;\n  var docLoadProtocol = document.location.protocol;\n  if ((scriptProtocol === 'resource:' ||\n       scriptProtocol === 'chrome-extension:') &&\n      docLoadProtocol !== scriptProtocol) {\n    return false;\n  }\n  return true;\n}\n\n// Cached as it has to run during loading so that document.currentScript is available.\nvar isAutoBootstrapAllowed = allowAutoBootstrap(window.document);\n\n/**\n * @ngdoc directive\n * @name ngApp\n * @module ng\n *\n * @element ANY\n * @param {angular.Module} ngApp an optional application\n *   {@link angular.module module} name to load.\n * @param {boolean=} ngStrictDi if this attribute is present on the app element, the injector will be\n *   created in \"strict-di\" mode. This means that the application will fail to invoke functions which\n *   do not use explicit function annotation (and are thus unsuitable for minification), as described\n *   in {@link guide/di the Dependency Injection guide}, and useful debugging info will assist in\n *   tracking down the root of these bugs.\n *\n * @description\n *\n * Use this directive to **auto-bootstrap** an AngularJS application. The `ngApp` directive\n * designates the **root element** of the application and is typically placed near the root element\n * of the page - e.g. on the `<body>` or `<html>` tags.\n *\n * There are a few things to keep in mind when using `ngApp`:\n * - only one AngularJS application can be auto-bootstrapped per HTML document. The first `ngApp`\n *   found in the document will be used to define the root element to auto-bootstrap as an\n *   application. To run multiple applications in an HTML document you must manually bootstrap them using\n *   {@link angular.bootstrap} instead.\n * - AngularJS applications cannot be nested within each other.\n * - Do not use a directive that uses {@link ng.$compile#transclusion transclusion} on the same element as `ngApp`.\n *   This includes directives such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and\n *   {@link ngRoute.ngView `ngView`}.\n *   Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},\n *   causing animations to stop working and making the injector inaccessible from outside the app.\n *\n * You can specify an **AngularJS module** to be used as the root module for the application.  This\n * module will be loaded into the {@link auto.$injector} when the application is bootstrapped. It\n * should contain the application code needed or have dependencies on other modules that will\n * contain the code. See {@link angular.module} for more information.\n *\n * In the example below if the `ngApp` directive were not placed on the `html` element then the\n * document would not be compiled, the `AppController` would not be instantiated and the `{{ a+b }}`\n * would not be resolved to `3`.\n *\n * `ngApp` is the easiest, and most common way to bootstrap an application.\n *\n <example module=\"ngAppDemo\" name=\"ng-app\">\n   <file name=\"index.html\">\n   <div ng-controller=\"ngAppDemoController\">\n     I can add: {{a}} + {{b}} =  {{ a+b }}\n   </div>\n   </file>\n   <file name=\"script.js\">\n   angular.module('ngAppDemo', []).controller('ngAppDemoController', function($scope) {\n     $scope.a = 1;\n     $scope.b = 2;\n   });\n   </file>\n </example>\n *\n * Using `ngStrictDi`, you would see something like this:\n *\n <example ng-app-included=\"true\" name=\"strict-di\">\n   <file name=\"index.html\">\n   <div ng-app=\"ngAppStrictDemo\" ng-strict-di>\n       <div ng-controller=\"GoodController1\">\n           I can add: {{a}} + {{b}} =  {{ a+b }}\n\n           <p>This renders because the controller does not fail to\n              instantiate, by using explicit annotation style (see\n              script.js for details)\n           </p>\n       </div>\n\n       <div ng-controller=\"GoodController2\">\n           Name: <input ng-model=\"name\"><br />\n           Hello, {{name}}!\n\n           <p>This renders because the controller does not fail to\n              instantiate, by using explicit annotation style\n              (see script.js for details)\n           </p>\n       </div>\n\n       <div ng-controller=\"BadController\">\n           I can add: {{a}} + {{b}} =  {{ a+b }}\n\n           <p>The controller could not be instantiated, due to relying\n              on automatic function annotations (which are disabled in\n              strict mode). As such, the content of this section is not\n              interpolated, and there should be an error in your web console.\n           </p>\n       </div>\n   </div>\n   </file>\n   <file name=\"script.js\">\n   angular.module('ngAppStrictDemo', [])\n     // BadController will fail to instantiate, due to relying on automatic function annotation,\n     // rather than an explicit annotation\n     .controller('BadController', function($scope) {\n       $scope.a = 1;\n       $scope.b = 2;\n     })\n     // Unlike BadController, GoodController1 and GoodController2 will not fail to be instantiated,\n     // due to using explicit annotations using the array style and $inject property, respectively.\n     .controller('GoodController1', ['$scope', function($scope) {\n       $scope.a = 1;\n       $scope.b = 2;\n     }])\n     .controller('GoodController2', GoodController2);\n     function GoodController2($scope) {\n       $scope.name = 'World';\n     }\n     GoodController2.$inject = ['$scope'];\n   </file>\n   <file name=\"style.css\">\n   div[ng-controller] {\n       margin-bottom: 1em;\n       -webkit-border-radius: 4px;\n       border-radius: 4px;\n       border: 1px solid;\n       padding: .5em;\n   }\n   div[ng-controller^=Good] {\n       border-color: #d6e9c6;\n       background-color: #dff0d8;\n       color: #3c763d;\n   }\n   div[ng-controller^=Bad] {\n       border-color: #ebccd1;\n       background-color: #f2dede;\n       color: #a94442;\n       margin-bottom: 0;\n   }\n   </file>\n </example>\n */\nfunction angularInit(element, bootstrap) {\n  var appElement,\n      module,\n      config = {};\n\n  // The element `element` has priority over any other element.\n  forEach(ngAttrPrefixes, function(prefix) {\n    var name = prefix + 'app';\n\n    if (!appElement && element.hasAttribute && element.hasAttribute(name)) {\n      appElement = element;\n      module = element.getAttribute(name);\n    }\n  });\n  forEach(ngAttrPrefixes, function(prefix) {\n    var name = prefix + 'app';\n    var candidate;\n\n    if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\\\:') + ']'))) {\n      appElement = candidate;\n      module = candidate.getAttribute(name);\n    }\n  });\n  if (appElement) {\n    if (!isAutoBootstrapAllowed) {\n      window.console.error('Angular: disabling automatic bootstrap. <script> protocol indicates ' +\n          'an extension, document.location.href does not match.');\n      return;\n    }\n    config.strictDi = getNgAttribute(appElement, 'strict-di') !== null;\n    bootstrap(appElement, module ? [module] : [], config);\n  }\n}\n\n/**\n * @ngdoc function\n * @name angular.bootstrap\n * @module ng\n * @description\n * Use this function to manually start up angular application.\n *\n * For more information, see the {@link guide/bootstrap Bootstrap guide}.\n *\n * Angular will detect if it has been loaded into the browser more than once and only allow the\n * first loaded script to be bootstrapped and will report a warning to the browser console for\n * each of the subsequent scripts. This prevents strange results in applications, where otherwise\n * multiple instances of Angular try to work on the DOM.\n *\n * <div class=\"alert alert-warning\">\n * **Note:** Protractor based end-to-end tests cannot use this function to bootstrap manually.\n * They must use {@link ng.directive:ngApp ngApp}.\n * </div>\n *\n * <div class=\"alert alert-warning\">\n * **Note:** Do not bootstrap the app on an element with a directive that uses {@link ng.$compile#transclusion transclusion},\n * such as {@link ng.ngIf `ngIf`}, {@link ng.ngInclude `ngInclude`} and {@link ngRoute.ngView `ngView`}.\n * Doing this misplaces the app {@link ng.$rootElement `$rootElement`} and the app's {@link auto.$injector injector},\n * causing animations to stop working and making the injector inaccessible from outside the app.\n * </div>\n *\n * ```html\n * <!doctype html>\n * <html>\n * <body>\n * <div ng-controller=\"WelcomeController\">\n *   {{greeting}}\n * </div>\n *\n * <script src=\"angular.js\"></script>\n * <script>\n *   var app = angular.module('demo', [])\n *   .controller('WelcomeController', function($scope) {\n *       $scope.greeting = 'Welcome!';\n *   });\n *   angular.bootstrap(document, ['demo']);\n * </script>\n * </body>\n * </html>\n * ```\n *\n * @param {DOMElement} element DOM element which is the root of angular application.\n * @param {Array<String|Function|Array>=} modules an array of modules to load into the application.\n *     Each item in the array should be the name of a predefined module or a (DI annotated)\n *     function that will be invoked by the injector as a `config` block.\n *     See: {@link angular.module modules}\n * @param {Object=} config an object for defining configuration options for the application. The\n *     following keys are supported:\n *\n * * `strictDi` - disable automatic function annotation for the application. This is meant to\n *   assist in finding bugs which break minified code. Defaults to `false`.\n *\n * @returns {auto.$injector} Returns the newly created injector for this app.\n */\nfunction bootstrap(element, modules, config) {\n  if (!isObject(config)) config = {};\n  var defaultConfig = {\n    strictDi: false\n  };\n  config = extend(defaultConfig, config);\n  var doBootstrap = function() {\n    element = jqLite(element);\n\n    if (element.injector()) {\n      var tag = (element[0] === window.document) ? 'document' : startingTag(element);\n      // Encode angle brackets to prevent input from being sanitized to empty string #8683.\n      throw ngMinErr(\n          'btstrpd',\n          'App already bootstrapped with this element \\'{0}\\'',\n          tag.replace(/</,'&lt;').replace(/>/,'&gt;'));\n    }\n\n    modules = modules || [];\n    modules.unshift(['$provide', function($provide) {\n      $provide.value('$rootElement', element);\n    }]);\n\n    if (config.debugInfoEnabled) {\n      // Pushing so that this overrides `debugInfoEnabled` setting defined in user's `modules`.\n      modules.push(['$compileProvider', function($compileProvider) {\n        $compileProvider.debugInfoEnabled(true);\n      }]);\n    }\n\n    modules.unshift('ng');\n    var injector = createInjector(modules, config.strictDi);\n    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector',\n       function bootstrapApply(scope, element, compile, injector) {\n        scope.$apply(function() {\n          element.data('$injector', injector);\n          compile(element)(scope);\n        });\n      }]\n    );\n    return injector;\n  };\n\n  var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;\n  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;\n\n  if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {\n    config.debugInfoEnabled = true;\n    window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');\n  }\n\n  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {\n    return doBootstrap();\n  }\n\n  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');\n  angular.resumeBootstrap = function(extraModules) {\n    forEach(extraModules, function(module) {\n      modules.push(module);\n    });\n    return doBootstrap();\n  };\n\n  if (isFunction(angular.resumeDeferredBootstrap)) {\n    angular.resumeDeferredBootstrap();\n  }\n}\n\n/**\n * @ngdoc function\n * @name angular.reloadWithDebugInfo\n * @module ng\n * @description\n * Use this function to reload the current application with debug information turned on.\n * This takes precedence over a call to `$compileProvider.debugInfoEnabled(false)`.\n *\n * See {@link ng.$compileProvider#debugInfoEnabled} for more.\n */\nfunction reloadWithDebugInfo() {\n  window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;\n  window.location.reload();\n}\n\n/**\n * @name angular.getTestability\n * @module ng\n * @description\n * Get the testability service for the instance of Angular on the given\n * element.\n * @param {DOMElement} element DOM element which is the root of angular application.\n */\nfunction getTestability(rootElement) {\n  var injector = angular.element(rootElement).injector();\n  if (!injector) {\n    throw ngMinErr('test',\n      'no injector found for element argument to getTestability');\n  }\n  return injector.get('$$testability');\n}\n\nvar SNAKE_CASE_REGEXP = /[A-Z]/g;\nfunction snake_case(name, separator) {\n  separator = separator || '_';\n  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {\n    return (pos ? separator : '') + letter.toLowerCase();\n  });\n}\n\nvar bindJQueryFired = false;\nfunction bindJQuery() {\n  var originalCleanData;\n\n  if (bindJQueryFired) {\n    return;\n  }\n\n  // bind to jQuery if present;\n  var jqName = jq();\n  jQuery = isUndefined(jqName) ? window.jQuery :   // use jQuery (if present)\n           !jqName             ? undefined     :   // use jqLite\n                                 window[jqName];   // use jQuery specified by `ngJq`\n\n  // Use jQuery if it exists with proper functionality, otherwise default to us.\n  // Angular 1.2+ requires jQuery 1.7+ for on()/off() support.\n  // Angular 1.3+ technically requires at least jQuery 2.1+ but it may work with older\n  // versions. It will not work for sure with jQuery <1.7, though.\n  if (jQuery && jQuery.fn.on) {\n    jqLite = jQuery;\n    extend(jQuery.fn, {\n      scope: JQLitePrototype.scope,\n      isolateScope: JQLitePrototype.isolateScope,\n      controller: JQLitePrototype.controller,\n      injector: JQLitePrototype.injector,\n      inheritedData: JQLitePrototype.inheritedData\n    });\n\n    // All nodes removed from the DOM via various jQuery APIs like .remove()\n    // are passed through jQuery.cleanData. Monkey-patch this method to fire\n    // the $destroy event on all removed nodes.\n    originalCleanData = jQuery.cleanData;\n    jQuery.cleanData = function(elems) {\n      var events;\n      for (var i = 0, elem; (elem = elems[i]) != null; i++) {\n        events = jQuery._data(elem, 'events');\n        if (events && events.$destroy) {\n          jQuery(elem).triggerHandler('$destroy');\n        }\n      }\n      originalCleanData(elems);\n    };\n  } else {\n    jqLite = JQLite;\n  }\n\n  angular.element = jqLite;\n\n  // Prevent double-proxying.\n  bindJQueryFired = true;\n}\n\n/**\n * throw error if the argument is falsy.\n */\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', 'Argument \\'{0}\\' is {1}', (name || '?'), (reason || 'required'));\n  }\n  return arg;\n}\n\nfunction assertArgFn(arg, name, acceptArrayAnnotation) {\n  if (acceptArrayAnnotation && isArray(arg)) {\n      arg = arg[arg.length - 1];\n  }\n\n  assertArg(isFunction(arg), name, 'not a function, got ' +\n      (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));\n  return arg;\n}\n\n/**\n * throw error if the name given is hasOwnProperty\n * @param  {String} name    the name to test\n * @param  {String} context the context in which the name is used, such as module or directive\n */\nfunction assertNotHasOwnProperty(name, context) {\n  if (name === 'hasOwnProperty') {\n    throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);\n  }\n}\n\n/**\n * Return the value accessible from the object by path. Any undefined traversals are ignored\n * @param {Object} obj starting object\n * @param {String} path path to traverse\n * @param {boolean} [bindFnToScope=true]\n * @returns {Object} value as accessible by path\n */\n//TODO(misko): this function needs to be removed\nfunction getter(obj, path, bindFnToScope) {\n  if (!path) return obj;\n  var keys = path.split('.');\n  var key;\n  var lastInstance = obj;\n  var len = keys.length;\n\n  for (var i = 0; i < len; i++) {\n    key = keys[i];\n    if (obj) {\n      obj = (lastInstance = obj)[key];\n    }\n  }\n  if (!bindFnToScope && isFunction(obj)) {\n    return bind(lastInstance, obj);\n  }\n  return obj;\n}\n\n/**\n * Return the DOM siblings between the first and last node in the given array.\n * @param {Array} array like object\n * @returns {Array} the inputted object or a jqLite collection containing the nodes\n */\nfunction getBlockNodes(nodes) {\n  // TODO(perf): update `nodes` instead of creating a new object?\n  var node = nodes[0];\n  var endNode = nodes[nodes.length - 1];\n  var blockNodes;\n\n  for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {\n    if (blockNodes || nodes[i] !== node) {\n      if (!blockNodes) {\n        blockNodes = jqLite(slice.call(nodes, 0, i));\n      }\n      blockNodes.push(node);\n    }\n  }\n\n  return blockNodes || nodes;\n}\n\n\n/**\n * Creates a new object without a prototype. This object is useful for lookup without having to\n * guard against prototypically inherited properties via hasOwnProperty.\n *\n * Related micro-benchmarks:\n * - http://jsperf.com/object-create2\n * - http://jsperf.com/proto-map-lookup/2\n * - http://jsperf.com/for-in-vs-object-keys2\n *\n * @returns {Object}\n */\nfunction createMap() {\n  return Object.create(null);\n}\n\nfunction stringify(value) {\n  if (value == null) { // null || undefined\n    return '';\n  }\n  switch (typeof value) {\n    case 'string':\n      break;\n    case 'number':\n      value = '' + value;\n      break;\n    default:\n      if (hasCustomToString(value) && !isArray(value) && !isDate(value)) {\n        value = value.toString();\n      } else {\n        value = toJson(value);\n      }\n  }\n\n  return value;\n}\n\nvar NODE_TYPE_ELEMENT = 1;\nvar NODE_TYPE_ATTRIBUTE = 2;\nvar NODE_TYPE_TEXT = 3;\nvar NODE_TYPE_COMMENT = 8;\nvar NODE_TYPE_DOCUMENT = 9;\nvar NODE_TYPE_DOCUMENT_FRAGMENT = 11;\n'use strict';\n\n/* global toDebugString: true */\n\nfunction serializeObject(obj) {\n  var seen = [];\n\n  return JSON.stringify(obj, function(key, val) {\n    val = toJsonReplacer(key, val);\n    if (isObject(val)) {\n\n      if (seen.indexOf(val) >= 0) return '...';\n\n      seen.push(val);\n    }\n    return val;\n  });\n}\n\nfunction toDebugString(obj) {\n  if (typeof obj === 'function') {\n    return obj.toString().replace(/ \\{[\\s\\S]*$/, '');\n  } else if (isUndefined(obj)) {\n    return 'undefined';\n  } else if (typeof obj !== 'string') {\n    return serializeObject(obj);\n  }\n  return obj;\n}\n'use strict';\n\n/**\n * @description\n *\n * This object provides a utility for producing rich Error messages within\n * Angular. It can be called as follows:\n *\n * var exampleMinErr = minErr('example');\n * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);\n *\n * The above creates an instance of minErr in the example namespace. The\n * resulting error will have a namespaced error code of example.one.  The\n * resulting error will replace {0} with the value of foo, and {1} with the\n * value of bar. The object is not restricted in the number of arguments it can\n * take.\n *\n * If fewer arguments are specified than necessary for interpolation, the extra\n * interpolation markers will be preserved in the final string.\n *\n * Since data will be parsed statically during a build step, some restrictions\n * are applied with respect to how minErr instances are created and called.\n * Instances should have names of the form namespaceMinErr for a minErr created\n * using minErr('namespace') . Error codes, namespaces and template strings\n * should all be static strings, not variables or general expressions.\n *\n * @param {string} module The namespace to use for the new minErr instance.\n * @param {function} ErrorConstructor Custom error constructor to be instantiated when returning\n *   error from returned function, for cases when a particular type of error is useful.\n * @returns {function(code:string, template:string, ...templateArgs): Error} minErr instance\n */\n\nfunction minErr(module, ErrorConstructor) {\n  ErrorConstructor = ErrorConstructor || Error;\n  return function() {\n    var SKIP_INDEXES = 2;\n\n    var templateArgs = arguments,\n      code = templateArgs[0],\n      message = '[' + (module ? module + ':' : '') + code + '] ',\n      template = templateArgs[1],\n      paramPrefix, i;\n\n    message += template.replace(/\\{\\d+\\}/g, function(match) {\n      var index = +match.slice(1, -1),\n        shiftedIndex = index + SKIP_INDEXES;\n\n      if (shiftedIndex < templateArgs.length) {\n        return toDebugString(templateArgs[shiftedIndex]);\n      }\n\n      return match;\n    });\n\n    message += '\\nhttp://errors.angularjs.org/\"NG_VERSION_FULL\"/' +\n      (module ? module + '/' : '') + code;\n\n    for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {\n      message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' +\n        encodeURIComponent(toDebugString(templateArgs[i]));\n    }\n\n    return new ErrorConstructor(message);\n  };\n}\n'use strict';\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *     Any commits to this file should be reviewed with security in mind.  *\n *   Changes to this file can potentially create security vulnerabilities. *\n *          An approval from 2 Core members with history of modifying      *\n *                         this file is required.                          *\n *                                                                         *\n *  Does the change somehow allow for arbitrary javascript to be executed? *\n *    Or allows for someone to change the prototype of built-in objects?   *\n *     Or gives undesired access to variables likes document or window?    *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nvar $parseMinErr = minErr('$parse');\n\nvar objectValueOf = {}.constructor.prototype.valueOf;\n\n// Sandboxing Angular Expressions\n// ------------------------------\n// Angular expressions are no longer sandboxed. So it is now even easier to access arbitrary JS code by\n// various means such as obtaining a reference to native JS functions like the Function constructor.\n//\n// As an example, consider the following Angular expression:\n//\n//   {}.toString.constructor('alert(\"evil JS code\")')\n//\n// It is important to realize that if you create an expression from a string that contains user provided\n// content then it is possible that your application contains a security vulnerability to an XSS style attack.\n//\n// See https://docs.angularjs.org/guide/security\n\n\nfunction getStringValue(name) {\n  // Property names must be strings. This means that non-string objects cannot be used\n  // as keys in an object. Any non-string object, including a number, is typecasted\n  // into a string via the toString method.\n  // -- MDN, https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors#Property_names\n  //\n  // So, to ensure that we are checking the same `name` that JavaScript would use, we cast it\n  // to a string. It's not always possible. If `name` is an object and its `toString` method is\n  // 'broken' (doesn't return a string, isn't a function, etc.), an error will be thrown:\n  //\n  // TypeError: Cannot convert object to primitive value\n  //\n  // For performance reasons, we don't catch this error here and allow it to propagate up the call\n  // stack. Note that you'll get the same error in JavaScript if you try to access a property using\n  // such a 'broken' object as a key.\n  return name + '';\n}\n\n\nvar OPERATORS = createMap();\nforEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) { OPERATORS[operator] = true; });\nvar ESCAPE = {'n':'\\n', 'f':'\\f', 'r':'\\r', 't':'\\t', 'v':'\\v', '\\'':'\\'', '\"':'\"'};\n\n\n/////////////////////////////////////////\n\n\n/**\n * @constructor\n */\nvar Lexer = function Lexer(options) {\n  this.options = options;\n};\n\nLexer.prototype = {\n  constructor: Lexer,\n\n  lex: function(text) {\n    this.text = text;\n    this.index = 0;\n    this.tokens = [];\n\n    while (this.index < this.text.length) {\n      var ch = this.text.charAt(this.index);\n      if (ch === '\"' || ch === '\\'') {\n        this.readString(ch);\n      } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {\n        this.readNumber();\n      } else if (this.isIdentifierStart(this.peekMultichar())) {\n        this.readIdent();\n      } else if (this.is(ch, '(){}[].,;:?')) {\n        this.tokens.push({index: this.index, text: ch});\n        this.index++;\n      } else if (this.isWhitespace(ch)) {\n        this.index++;\n      } else {\n        var ch2 = ch + this.peek();\n        var ch3 = ch2 + this.peek(2);\n        var op1 = OPERATORS[ch];\n        var op2 = OPERATORS[ch2];\n        var op3 = OPERATORS[ch3];\n        if (op1 || op2 || op3) {\n          var token = op3 ? ch3 : (op2 ? ch2 : ch);\n          this.tokens.push({index: this.index, text: token, operator: true});\n          this.index += token.length;\n        } else {\n          this.throwError('Unexpected next character ', this.index, this.index + 1);\n        }\n      }\n    }\n    return this.tokens;\n  },\n\n  is: function(ch, chars) {\n    return chars.indexOf(ch) !== -1;\n  },\n\n  peek: function(i) {\n    var num = i || 1;\n    return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;\n  },\n\n  isNumber: function(ch) {\n    return ('0' <= ch && ch <= '9') && typeof ch === 'string';\n  },\n\n  isWhitespace: function(ch) {\n    // IE treats non-breaking space as \\u00A0\n    return (ch === ' ' || ch === '\\r' || ch === '\\t' ||\n            ch === '\\n' || ch === '\\v' || ch === '\\u00A0');\n  },\n\n  isIdentifierStart: function(ch) {\n    return this.options.isIdentifierStart ?\n        this.options.isIdentifierStart(ch, this.codePointAt(ch)) :\n        this.isValidIdentifierStart(ch);\n  },\n\n  isValidIdentifierStart: function(ch) {\n    return ('a' <= ch && ch <= 'z' ||\n            'A' <= ch && ch <= 'Z' ||\n            '_' === ch || ch === '$');\n  },\n\n  isIdentifierContinue: function(ch) {\n    return this.options.isIdentifierContinue ?\n        this.options.isIdentifierContinue(ch, this.codePointAt(ch)) :\n        this.isValidIdentifierContinue(ch);\n  },\n\n  isValidIdentifierContinue: function(ch, cp) {\n    return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);\n  },\n\n  codePointAt: function(ch) {\n    if (ch.length === 1) return ch.charCodeAt(0);\n    // eslint-disable-next-line no-bitwise\n    return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 0x35FDC00;\n  },\n\n  peekMultichar: function() {\n    var ch = this.text.charAt(this.index);\n    var peek = this.peek();\n    if (!peek) {\n      return ch;\n    }\n    var cp1 = ch.charCodeAt(0);\n    var cp2 = peek.charCodeAt(0);\n    if (cp1 >= 0xD800 && cp1 <= 0xDBFF && cp2 >= 0xDC00 && cp2 <= 0xDFFF) {\n      return ch + peek;\n    }\n    return ch;\n  },\n\n  isExpOperator: function(ch) {\n    return (ch === '-' || ch === '+' || this.isNumber(ch));\n  },\n\n  throwError: function(error, start, end) {\n    end = end || this.index;\n    var colStr = (isDefined(start)\n            ? 's ' + start +  '-' + this.index + ' [' + this.text.substring(start, end) + ']'\n            : ' ' + end);\n    throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].',\n        error, colStr, this.text);\n  },\n\n  readNumber: function() {\n    var number = '';\n    var start = this.index;\n    while (this.index < this.text.length) {\n      var ch = lowercase(this.text.charAt(this.index));\n      if (ch === '.' || this.isNumber(ch)) {\n        number += ch;\n      } else {\n        var peekCh = this.peek();\n        if (ch === 'e' && this.isExpOperator(peekCh)) {\n          number += ch;\n        } else if (this.isExpOperator(ch) &&\n            peekCh && this.isNumber(peekCh) &&\n            number.charAt(number.length - 1) === 'e') {\n          number += ch;\n        } else if (this.isExpOperator(ch) &&\n            (!peekCh || !this.isNumber(peekCh)) &&\n            number.charAt(number.length - 1) === 'e') {\n          this.throwError('Invalid exponent');\n        } else {\n          break;\n        }\n      }\n      this.index++;\n    }\n    this.tokens.push({\n      index: start,\n      text: number,\n      constant: true,\n      value: Number(number)\n    });\n  },\n\n  readIdent: function() {\n    var start = this.index;\n    this.index += this.peekMultichar().length;\n    while (this.index < this.text.length) {\n      var ch = this.peekMultichar();\n      if (!this.isIdentifierContinue(ch)) {\n        break;\n      }\n      this.index += ch.length;\n    }\n    this.tokens.push({\n      index: start,\n      text: this.text.slice(start, this.index),\n      identifier: true\n    });\n  },\n\n  readString: function(quote) {\n    var start = this.index;\n    this.index++;\n    var string = '';\n    var rawString = quote;\n    var escape = false;\n    while (this.index < this.text.length) {\n      var ch = this.text.charAt(this.index);\n      rawString += ch;\n      if (escape) {\n        if (ch === 'u') {\n          var hex = this.text.substring(this.index + 1, this.index + 5);\n          if (!hex.match(/[\\da-f]{4}/i)) {\n            this.throwError('Invalid unicode escape [\\\\u' + hex + ']');\n          }\n          this.index += 4;\n          string += String.fromCharCode(parseInt(hex, 16));\n        } else {\n          var rep = ESCAPE[ch];\n          string = string + (rep || ch);\n        }\n        escape = false;\n      } else if (ch === '\\\\') {\n        escape = true;\n      } else if (ch === quote) {\n        this.index++;\n        this.tokens.push({\n          index: start,\n          text: rawString,\n          constant: true,\n          value: string\n        });\n        return;\n      } else {\n        string += ch;\n      }\n      this.index++;\n    }\n    this.throwError('Unterminated quote', start);\n  }\n};\n\nvar AST = function AST(lexer, options) {\n  this.lexer = lexer;\n  this.options = options;\n};\n\nAST.Program = 'Program';\nAST.ExpressionStatement = 'ExpressionStatement';\nAST.AssignmentExpression = 'AssignmentExpression';\nAST.ConditionalExpression = 'ConditionalExpression';\nAST.LogicalExpression = 'LogicalExpression';\nAST.BinaryExpression = 'BinaryExpression';\nAST.UnaryExpression = 'UnaryExpression';\nAST.CallExpression = 'CallExpression';\nAST.MemberExpression = 'MemberExpression';\nAST.Identifier = 'Identifier';\nAST.Literal = 'Literal';\nAST.ArrayExpression = 'ArrayExpression';\nAST.Property = 'Property';\nAST.ObjectExpression = 'ObjectExpression';\nAST.ThisExpression = 'ThisExpression';\nAST.LocalsExpression = 'LocalsExpression';\n\n// Internal use only\nAST.NGValueParameter = 'NGValueParameter';\n\nAST.prototype = {\n  ast: function(text) {\n    this.text = text;\n    this.tokens = this.lexer.lex(text);\n\n    var value = this.program();\n\n    if (this.tokens.length !== 0) {\n      this.throwError('is an unexpected token', this.tokens[0]);\n    }\n\n    return value;\n  },\n\n  program: function() {\n    var body = [];\n    while (true) {\n      if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))\n        body.push(this.expressionStatement());\n      if (!this.expect(';')) {\n        return { type: AST.Program, body: body};\n      }\n    }\n  },\n\n  expressionStatement: function() {\n    return { type: AST.ExpressionStatement, expression: this.filterChain() };\n  },\n\n  filterChain: function() {\n    var left = this.expression();\n    while (this.expect('|')) {\n      left = this.filter(left);\n    }\n    return left;\n  },\n\n  expression: function() {\n    return this.assignment();\n  },\n\n  assignment: function() {\n    var result = this.ternary();\n    if (this.expect('=')) {\n      if (!isAssignable(result)) {\n        throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');\n      }\n\n      result = { type: AST.AssignmentExpression, left: result, right: this.assignment(), operator: '='};\n    }\n    return result;\n  },\n\n  ternary: function() {\n    var test = this.logicalOR();\n    var alternate;\n    var consequent;\n    if (this.expect('?')) {\n      alternate = this.expression();\n      if (this.consume(':')) {\n        consequent = this.expression();\n        return { type: AST.ConditionalExpression, test: test, alternate: alternate, consequent: consequent};\n      }\n    }\n    return test;\n  },\n\n  logicalOR: function() {\n    var left = this.logicalAND();\n    while (this.expect('||')) {\n      left = { type: AST.LogicalExpression, operator: '||', left: left, right: this.logicalAND() };\n    }\n    return left;\n  },\n\n  logicalAND: function() {\n    var left = this.equality();\n    while (this.expect('&&')) {\n      left = { type: AST.LogicalExpression, operator: '&&', left: left, right: this.equality()};\n    }\n    return left;\n  },\n\n  equality: function() {\n    var left = this.relational();\n    var token;\n    while ((token = this.expect('==','!=','===','!=='))) {\n      left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.relational() };\n    }\n    return left;\n  },\n\n  relational: function() {\n    var left = this.additive();\n    var token;\n    while ((token = this.expect('<', '>', '<=', '>='))) {\n      left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.additive() };\n    }\n    return left;\n  },\n\n  additive: function() {\n    var left = this.multiplicative();\n    var token;\n    while ((token = this.expect('+','-'))) {\n      left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.multiplicative() };\n    }\n    return left;\n  },\n\n  multiplicative: function() {\n    var left = this.unary();\n    var token;\n    while ((token = this.expect('*','/','%'))) {\n      left = { type: AST.BinaryExpression, operator: token.text, left: left, right: this.unary() };\n    }\n    return left;\n  },\n\n  unary: function() {\n    var token;\n    if ((token = this.expect('+', '-', '!'))) {\n      return { type: AST.UnaryExpression, operator: token.text, prefix: true, argument: this.unary() };\n    } else {\n      return this.primary();\n    }\n  },\n\n  primary: function() {\n    var primary;\n    if (this.expect('(')) {\n      primary = this.filterChain();\n      this.consume(')');\n    } else if (this.expect('[')) {\n      primary = this.arrayDeclaration();\n    } else if (this.expect('{')) {\n      primary = this.object();\n    } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {\n      primary = copy(this.selfReferential[this.consume().text]);\n    } else if (this.options.literals.hasOwnProperty(this.peek().text)) {\n      primary = { type: AST.Literal, value: this.options.literals[this.consume().text]};\n    } else if (this.peek().identifier) {\n      primary = this.identifier();\n    } else if (this.peek().constant) {\n      primary = this.constant();\n    } else {\n      this.throwError('not a primary expression', this.peek());\n    }\n\n    var next;\n    while ((next = this.expect('(', '[', '.'))) {\n      if (next.text === '(') {\n        primary = {type: AST.CallExpression, callee: primary, arguments: this.parseArguments() };\n        this.consume(')');\n      } else if (next.text === '[') {\n        primary = { type: AST.MemberExpression, object: primary, property: this.expression(), computed: true };\n        this.consume(']');\n      } else if (next.text === '.') {\n        primary = { type: AST.MemberExpression, object: primary, property: this.identifier(), computed: false };\n      } else {\n        this.throwError('IMPOSSIBLE');\n      }\n    }\n    return primary;\n  },\n\n  filter: function(baseExpression) {\n    var args = [baseExpression];\n    var result = {type: AST.CallExpression, callee: this.identifier(), arguments: args, filter: true};\n\n    while (this.expect(':')) {\n      args.push(this.expression());\n    }\n\n    return result;\n  },\n\n  parseArguments: function() {\n    var args = [];\n    if (this.peekToken().text !== ')') {\n      do {\n        args.push(this.filterChain());\n      } while (this.expect(','));\n    }\n    return args;\n  },\n\n  identifier: function() {\n    var token = this.consume();\n    if (!token.identifier) {\n      this.throwError('is not a valid identifier', token);\n    }\n    return { type: AST.Identifier, name: token.text };\n  },\n\n  constant: function() {\n    // TODO check that it is a constant\n    return { type: AST.Literal, value: this.consume().value };\n  },\n\n  arrayDeclaration: function() {\n    var elements = [];\n    if (this.peekToken().text !== ']') {\n      do {\n        if (this.peek(']')) {\n          // Support trailing commas per ES5.1.\n          break;\n        }\n        elements.push(this.expression());\n      } while (this.expect(','));\n    }\n    this.consume(']');\n\n    return { type: AST.ArrayExpression, elements: elements };\n  },\n\n  object: function() {\n    var properties = [], property;\n    if (this.peekToken().text !== '}') {\n      do {\n        if (this.peek('}')) {\n          // Support trailing commas per ES5.1.\n          break;\n        }\n        property = {type: AST.Property, kind: 'init'};\n        if (this.peek().constant) {\n          property.key = this.constant();\n          property.computed = false;\n          this.consume(':');\n          property.value = this.expression();\n        } else if (this.peek().identifier) {\n          property.key = this.identifier();\n          property.computed = false;\n          if (this.peek(':')) {\n            this.consume(':');\n            property.value = this.expression();\n          } else {\n            property.value = property.key;\n          }\n        } else if (this.peek('[')) {\n          this.consume('[');\n          property.key = this.expression();\n          this.consume(']');\n          property.computed = true;\n          this.consume(':');\n          property.value = this.expression();\n        } else {\n          this.throwError('invalid key', this.peek());\n        }\n        properties.push(property);\n      } while (this.expect(','));\n    }\n    this.consume('}');\n\n    return {type: AST.ObjectExpression, properties: properties };\n  },\n\n  throwError: function(msg, token) {\n    throw $parseMinErr('syntax',\n        'Syntax Error: Token \\'{0}\\' {1} at column {2} of the expression [{3}] starting at [{4}].',\n          token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));\n  },\n\n  consume: function(e1) {\n    if (this.tokens.length === 0) {\n      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);\n    }\n\n    var token = this.expect(e1);\n    if (!token) {\n      this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());\n    }\n    return token;\n  },\n\n  peekToken: function() {\n    if (this.tokens.length === 0) {\n      throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);\n    }\n    return this.tokens[0];\n  },\n\n  peek: function(e1, e2, e3, e4) {\n    return this.peekAhead(0, e1, e2, e3, e4);\n  },\n\n  peekAhead: function(i, e1, e2, e3, e4) {\n    if (this.tokens.length > i) {\n      var token = this.tokens[i];\n      var t = token.text;\n      if (t === e1 || t === e2 || t === e3 || t === e4 ||\n          (!e1 && !e2 && !e3 && !e4)) {\n        return token;\n      }\n    }\n    return false;\n  },\n\n  expect: function(e1, e2, e3, e4) {\n    var token = this.peek(e1, e2, e3, e4);\n    if (token) {\n      this.tokens.shift();\n      return token;\n    }\n    return false;\n  },\n\n  selfReferential: {\n    'this': {type: AST.ThisExpression },\n    '$locals': {type: AST.LocalsExpression }\n  }\n};\n\nfunction ifDefined(v, d) {\n  return typeof v !== 'undefined' ? v : d;\n}\n\nfunction plusFn(l, r) {\n  if (typeof l === 'undefined') return r;\n  if (typeof r === 'undefined') return l;\n  return l + r;\n}\n\nfunction isStateless($filter, filterName) {\n  var fn = $filter(filterName);\n  return !fn.$stateful;\n}\n\nfunction findConstantAndWatchExpressions(ast, $filter) {\n  var allConstants;\n  var argsToWatch;\n  var isStatelessFilter;\n  switch (ast.type) {\n  case AST.Program:\n    allConstants = true;\n    forEach(ast.body, function(expr) {\n      findConstantAndWatchExpressions(expr.expression, $filter);\n      allConstants = allConstants && expr.expression.constant;\n    });\n    ast.constant = allConstants;\n    break;\n  case AST.Literal:\n    ast.constant = true;\n    ast.toWatch = [];\n    break;\n  case AST.UnaryExpression:\n    findConstantAndWatchExpressions(ast.argument, $filter);\n    ast.constant = ast.argument.constant;\n    ast.toWatch = ast.argument.toWatch;\n    break;\n  case AST.BinaryExpression:\n    findConstantAndWatchExpressions(ast.left, $filter);\n    findConstantAndWatchExpressions(ast.right, $filter);\n    ast.constant = ast.left.constant && ast.right.constant;\n    ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);\n    break;\n  case AST.LogicalExpression:\n    findConstantAndWatchExpressions(ast.left, $filter);\n    findConstantAndWatchExpressions(ast.right, $filter);\n    ast.constant = ast.left.constant && ast.right.constant;\n    ast.toWatch = ast.constant ? [] : [ast];\n    break;\n  case AST.ConditionalExpression:\n    findConstantAndWatchExpressions(ast.test, $filter);\n    findConstantAndWatchExpressions(ast.alternate, $filter);\n    findConstantAndWatchExpressions(ast.consequent, $filter);\n    ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;\n    ast.toWatch = ast.constant ? [] : [ast];\n    break;\n  case AST.Identifier:\n    ast.constant = false;\n    ast.toWatch = [ast];\n    break;\n  case AST.MemberExpression:\n    findConstantAndWatchExpressions(ast.object, $filter);\n    if (ast.computed) {\n      findConstantAndWatchExpressions(ast.property, $filter);\n    }\n    ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);\n    ast.toWatch = [ast];\n    break;\n  case AST.CallExpression:\n    isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : false;\n    allConstants = isStatelessFilter;\n    argsToWatch = [];\n    forEach(ast.arguments, function(expr) {\n      findConstantAndWatchExpressions(expr, $filter);\n      allConstants = allConstants && expr.constant;\n      if (!expr.constant) {\n        argsToWatch.push.apply(argsToWatch, expr.toWatch);\n      }\n    });\n    ast.constant = allConstants;\n    ast.toWatch = isStatelessFilter ? argsToWatch : [ast];\n    break;\n  case AST.AssignmentExpression:\n    findConstantAndWatchExpressions(ast.left, $filter);\n    findConstantAndWatchExpressions(ast.right, $filter);\n    ast.constant = ast.left.constant && ast.right.constant;\n    ast.toWatch = [ast];\n    break;\n  case AST.ArrayExpression:\n    allConstants = true;\n    argsToWatch = [];\n    forEach(ast.elements, function(expr) {\n      findConstantAndWatchExpressions(expr, $filter);\n      allConstants = allConstants && expr.constant;\n      if (!expr.constant) {\n        argsToWatch.push.apply(argsToWatch, expr.toWatch);\n      }\n    });\n    ast.constant = allConstants;\n    ast.toWatch = argsToWatch;\n    break;\n  case AST.ObjectExpression:\n    allConstants = true;\n    argsToWatch = [];\n    forEach(ast.properties, function(property) {\n      findConstantAndWatchExpressions(property.value, $filter);\n      allConstants = allConstants && property.value.constant && !property.computed;\n      if (!property.value.constant) {\n        argsToWatch.push.apply(argsToWatch, property.value.toWatch);\n      }\n    });\n    ast.constant = allConstants;\n    ast.toWatch = argsToWatch;\n    break;\n  case AST.ThisExpression:\n    ast.constant = false;\n    ast.toWatch = [];\n    break;\n  case AST.LocalsExpression:\n    ast.constant = false;\n    ast.toWatch = [];\n    break;\n  }\n}\n\nfunction getInputs(body) {\n  if (body.length !== 1) return;\n  var lastExpression = body[0].expression;\n  var candidate = lastExpression.toWatch;\n  if (candidate.length !== 1) return candidate;\n  return candidate[0] !== lastExpression ? candidate : undefined;\n}\n\nfunction isAssignable(ast) {\n  return ast.type === AST.Identifier || ast.type === AST.MemberExpression;\n}\n\nfunction assignableAST(ast) {\n  if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {\n    return {type: AST.AssignmentExpression, left: ast.body[0].expression, right: {type: AST.NGValueParameter}, operator: '='};\n  }\n}\n\nfunction isLiteral(ast) {\n  return ast.body.length === 0 ||\n      ast.body.length === 1 && (\n      ast.body[0].expression.type === AST.Literal ||\n      ast.body[0].expression.type === AST.ArrayExpression ||\n      ast.body[0].expression.type === AST.ObjectExpression);\n}\n\nfunction isConstant(ast) {\n  return ast.constant;\n}\n\nfunction ASTCompiler(astBuilder, $filter) {\n  this.astBuilder = astBuilder;\n  this.$filter = $filter;\n}\n\nASTCompiler.prototype = {\n  compile: function(expression) {\n    var self = this;\n    var ast = this.astBuilder.ast(expression);\n    this.state = {\n      nextId: 0,\n      filters: {},\n      fn: {vars: [], body: [], own: {}},\n      assign: {vars: [], body: [], own: {}},\n      inputs: []\n    };\n    findConstantAndWatchExpressions(ast, self.$filter);\n    var extra = '';\n    var assignable;\n    this.stage = 'assign';\n    if ((assignable = assignableAST(ast))) {\n      this.state.computing = 'assign';\n      var result = this.nextId();\n      this.recurse(assignable, result);\n      this.return_(result);\n      extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');\n    }\n    var toWatch = getInputs(ast.body);\n    self.stage = 'inputs';\n    forEach(toWatch, function(watch, key) {\n      var fnKey = 'fn' + key;\n      self.state[fnKey] = {vars: [], body: [], own: {}};\n      self.state.computing = fnKey;\n      var intoId = self.nextId();\n      self.recurse(watch, intoId);\n      self.return_(intoId);\n      self.state.inputs.push(fnKey);\n      watch.watchId = key;\n    });\n    this.state.computing = 'fn';\n    this.stage = 'main';\n    this.recurse(ast);\n    var fnString =\n      // The build and minification steps remove the string \"use strict\" from the code, but this is done using a regex.\n      // This is a workaround for this until we do a better job at only removing the prefix only when we should.\n      '\"' + this.USE + ' ' + this.STRICT + '\";\\n' +\n      this.filterPrefix() +\n      'var fn=' + this.generateFunction('fn', 's,l,a,i') +\n      extra +\n      this.watchFns() +\n      'return fn;';\n\n    // eslint-disable-next-line no-new-func\n    var fn = (new Function('$filter',\n        'getStringValue',\n        'ifDefined',\n        'plus',\n        fnString))(\n          this.$filter,\n          getStringValue,\n          ifDefined,\n          plusFn);\n    this.state = this.stage = undefined;\n    fn.ast = ast;\nfn.literal = isLiteral(ast);\n    fn.constant = isConstant(ast);\n    return fn;\n  },\n\n  USE: 'use',\n\n  STRICT: 'strict',\n\n  watchFns: function() {\n    var result = [];\n    var fns = this.state.inputs;\n    var self = this;\n    forEach(fns, function(name) {\n      result.push('var ' + name + '=' + self.generateFunction(name, 's'));\n    });\n    if (fns.length) {\n      result.push('fn.inputs=[' + fns.join(',') + '];');\n    }\n    return result.join('');\n  },\n\n  generateFunction: function(name, params) {\n    return 'function(' + params + '){' +\n        this.varsPrefix(name) +\n        this.body(name) +\n        '};';\n  },\n\n  filterPrefix: function() {\n    var parts = [];\n    var self = this;\n    forEach(this.state.filters, function(id, filter) {\n      parts.push(id + '=$filter(' + self.escape(filter) + ')');\n    });\n    if (parts.length) return 'var ' + parts.join(',') + ';';\n    return '';\n  },\n\n  varsPrefix: function(section) {\n    return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';\n  },\n\n  body: function(section) {\n    return this.state[section].body.join('');\n  },\n\n  recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {\n    var left, right, self = this, args, expression, computed;\n    recursionFn = recursionFn || noop;\n    if (!skipWatchIdCheck && isDefined(ast.watchId)) {\n      intoId = intoId || this.nextId();\n      this.if_('i',\n        this.lazyAssign(intoId, this.computedMember('i', ast.watchId)),\n        this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true)\n      );\n      return;\n    }\n    switch (ast.type) {\n    case AST.Program:\n      forEach(ast.body, function(expression, pos) {\n        self.recurse(expression.expression, undefined, undefined, function(expr) { right = expr; });\n        if (pos !== ast.body.length - 1) {\n          self.current().body.push(right, ';');\n        } else {\n          self.return_(right);\n        }\n      });\n      break;\n    case AST.Literal:\n      expression = this.escape(ast.value);\n      this.assign(intoId, expression);\n      recursionFn(intoId || expression);\n      break;\n    case AST.UnaryExpression:\n      this.recurse(ast.argument, undefined, undefined, function(expr) { right = expr; });\n      expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';\n      this.assign(intoId, expression);\n      recursionFn(expression);\n      break;\n    case AST.BinaryExpression:\n      this.recurse(ast.left, undefined, undefined, function(expr) { left = expr; });\n      this.recurse(ast.right, undefined, undefined, function(expr) { right = expr; });\n      if (ast.operator === '+') {\n        expression = this.plus(left, right);\n      } else if (ast.operator === '-') {\n        expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);\n      } else {\n        expression = '(' + left + ')' + ast.operator + '(' + right + ')';\n      }\n      this.assign(intoId, expression);\n      recursionFn(expression);\n      break;\n    case AST.LogicalExpression:\n      intoId = intoId || this.nextId();\n      self.recurse(ast.left, intoId);\n      self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));\n      recursionFn(intoId);\n      break;\n    case AST.ConditionalExpression:\n      intoId = intoId || this.nextId();\n      self.recurse(ast.test, intoId);\n      self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));\n      recursionFn(intoId);\n      break;\n    case AST.Identifier:\n      intoId = intoId || this.nextId();\n      if (nameId) {\n        nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');\n        nameId.computed = false;\n        nameId.name = ast.name;\n      }\n      self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)),\n        function() {\n          self.if_(self.stage === 'inputs' || 's', function() {\n            if (create && create !== 1) {\n              self.if_(\n                self.isNull(self.nonComputedMember('s', ast.name)),\n                self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));\n            }\n            self.assign(intoId, self.nonComputedMember('s', ast.name));\n          });\n        }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name))\n        );\n      recursionFn(intoId);\n      break;\n    case AST.MemberExpression:\n      left = nameId && (nameId.context = this.nextId()) || this.nextId();\n      intoId = intoId || this.nextId();\n      self.recurse(ast.object, left, undefined, function() {\n        self.if_(self.notNull(left), function() {\n          if (ast.computed) {\n            right = self.nextId();\n            self.recurse(ast.property, right);\n            self.getStringValue(right);\n            if (create && create !== 1) {\n              self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));\n            }\n            expression = self.computedMember(left, right);\n            self.assign(intoId, expression);\n            if (nameId) {\n              nameId.computed = true;\n              nameId.name = right;\n            }\n          } else {\n            if (create && create !== 1) {\n              self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));\n            }\n            expression = self.nonComputedMember(left, ast.property.name);\n            self.assign(intoId, expression);\n            if (nameId) {\n              nameId.computed = false;\n              nameId.name = ast.property.name;\n            }\n          }\n        }, function() {\n          self.assign(intoId, 'undefined');\n        });\n        recursionFn(intoId);\n      }, !!create);\n      break;\n    case AST.CallExpression:\n      intoId = intoId || this.nextId();\n      if (ast.filter) {\n        right = self.filter(ast.callee.name);\n        args = [];\n        forEach(ast.arguments, function(expr) {\n          var argument = self.nextId();\n          self.recurse(expr, argument);\n          args.push(argument);\n        });\n        expression = right + '(' + args.join(',') + ')';\n        self.assign(intoId, expression);\n        recursionFn(intoId);\n      } else {\n        right = self.nextId();\n        left = {};\n        args = [];\n        self.recurse(ast.callee, right, left, function() {\n          self.if_(self.notNull(right), function() {\n            forEach(ast.arguments, function(expr) {\n              self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function(argument) {\n                args.push(argument);\n              });\n            });\n            if (left.name) {\n              expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';\n            } else {\n              expression = right + '(' + args.join(',') + ')';\n            }\n            self.assign(intoId, expression);\n          }, function() {\n            self.assign(intoId, 'undefined');\n          });\n          recursionFn(intoId);\n        });\n      }\n      break;\n    case AST.AssignmentExpression:\n      right = this.nextId();\n      left = {};\n      this.recurse(ast.left, undefined, left, function() {\n        self.if_(self.notNull(left.context), function() {\n          self.recurse(ast.right, right);\n          expression = self.member(left.context, left.name, left.computed) + ast.operator + right;\n          self.assign(intoId, expression);\n          recursionFn(intoId || expression);\n        });\n      }, 1);\n      break;\n    case AST.ArrayExpression:\n      args = [];\n      forEach(ast.elements, function(expr) {\n        self.recurse(expr, ast.constant ? undefined : self.nextId(), undefined, function(argument) {\n          args.push(argument);\n        });\n      });\n      expression = '[' + args.join(',') + ']';\n      this.assign(intoId, expression);\n      recursionFn(intoId || expression);\n      break;\n    case AST.ObjectExpression:\n      args = [];\n      computed = false;\n      forEach(ast.properties, function(property) {\n        if (property.computed) {\n          computed = true;\n        }\n      });\n      if (computed) {\n        intoId = intoId || this.nextId();\n        this.assign(intoId, '{}');\n        forEach(ast.properties, function(property) {\n          if (property.computed) {\n            left = self.nextId();\n            self.recurse(property.key, left);\n          } else {\n            left = property.key.type === AST.Identifier ?\n                       property.key.name :\n                       ('' + property.key.value);\n          }\n          right = self.nextId();\n          self.recurse(property.value, right);\n          self.assign(self.member(intoId, left, property.computed), right);\n        });\n      } else {\n        forEach(ast.properties, function(property) {\n          self.recurse(property.value, ast.constant ? undefined : self.nextId(), undefined, function(expr) {\n            args.push(self.escape(\n                property.key.type === AST.Identifier ? property.key.name :\n                  ('' + property.key.value)) +\n                ':' + expr);\n          });\n        });\n        expression = '{' + args.join(',') + '}';\n        this.assign(intoId, expression);\n      }\n      recursionFn(intoId || expression);\n      break;\n    case AST.ThisExpression:\n      this.assign(intoId, 's');\n      recursionFn(intoId || 's');\n      break;\n    case AST.LocalsExpression:\n      this.assign(intoId, 'l');\n      recursionFn(intoId || 'l');\n      break;\n    case AST.NGValueParameter:\n      this.assign(intoId, 'v');\n      recursionFn(intoId || 'v');\n      break;\n    }\n  },\n\n  getHasOwnProperty: function(element, property) {\n    var key = element + '.' + property;\n    var own = this.current().own;\n    if (!own.hasOwnProperty(key)) {\n      own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');\n    }\n    return own[key];\n  },\n\n  assign: function(id, value) {\n    if (!id) return;\n    this.current().body.push(id, '=', value, ';');\n    return id;\n  },\n\n  filter: function(filterName) {\n    if (!this.state.filters.hasOwnProperty(filterName)) {\n      this.state.filters[filterName] = this.nextId(true);\n    }\n    return this.state.filters[filterName];\n  },\n\n  ifDefined: function(id, defaultValue) {\n    return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';\n  },\n\n  plus: function(left, right) {\n    return 'plus(' + left + ',' + right + ')';\n  },\n\n  return_: function(id) {\n    this.current().body.push('return ', id, ';');\n  },\n\n  if_: function(test, alternate, consequent) {\n    if (test === true) {\n      alternate();\n    } else {\n      var body = this.current().body;\n      body.push('if(', test, '){');\n      alternate();\n      body.push('}');\n      if (consequent) {\n        body.push('else{');\n        consequent();\n        body.push('}');\n      }\n    }\n  },\n\n  not: function(expression) {\n    return '!(' + expression + ')';\n  },\n\n  isNull: function(expression) {\n    return expression + '==null';\n  },\n\n  notNull: function(expression) {\n    return expression + '!=null';\n  },\n\n  nonComputedMember: function(left, right) {\n    var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;\n    var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;\n    if (SAFE_IDENTIFIER.test(right)) {\n      return left + '.' + right;\n    } else {\n      return left  + '[\"' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '\"]';\n    }\n  },\n\n  computedMember: function(left, right) {\n    return left + '[' + right + ']';\n  },\n\n  member: function(left, right, computed) {\n    if (computed) return this.computedMember(left, right);\n    return this.nonComputedMember(left, right);\n  },\n\n  getStringValue: function(item) {\n    this.assign(item, 'getStringValue(' + item + ')');\n  },\n\n  lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {\n    var self = this;\n    return function() {\n      self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);\n    };\n  },\n\n  lazyAssign: function(id, value) {\n    var self = this;\n    return function() {\n      self.assign(id, value);\n    };\n  },\n\n  stringEscapeRegex: /[^ a-zA-Z0-9]/g,\n\n  stringEscapeFn: function(c) {\n    return '\\\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);\n  },\n\n  escape: function(value) {\n    if (isString(value)) return '\\'' + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + '\\'';\n    if (isNumber(value)) return value.toString();\n    if (value === true) return 'true';\n    if (value === false) return 'false';\n    if (value === null) return 'null';\n    if (typeof value === 'undefined') return 'undefined';\n\n    throw $parseMinErr('esc', 'IMPOSSIBLE');\n  },\n\n  nextId: function(skip, init) {\n    var id = 'v' + (this.state.nextId++);\n    if (!skip) {\n      this.current().vars.push(id + (init ? '=' + init : ''));\n    }\n    return id;\n  },\n\n  current: function() {\n    return this.state[this.state.computing];\n  }\n};\n\n\nfunction ASTInterpreter(astBuilder, $filter) {\n  this.astBuilder = astBuilder;\n  this.$filter = $filter;\n}\n\nASTInterpreter.prototype = {\n  compile: function(expression) {\n    var self = this;\n    var ast = this.astBuilder.ast(expression);\n    findConstantAndWatchExpressions(ast, self.$filter);\n    var assignable;\n    var assign;\n    if ((assignable = assignableAST(ast))) {\n      assign = this.recurse(assignable);\n    }\n    var toWatch = getInputs(ast.body);\n    var inputs;\n    if (toWatch) {\n      inputs = [];\n      forEach(toWatch, function(watch, key) {\n        var input = self.recurse(watch);\n        watch.input = input;\n        inputs.push(input);\n        watch.watchId = key;\n      });\n    }\n    var expressions = [];\n    forEach(ast.body, function(expression) {\n      expressions.push(self.recurse(expression.expression));\n    });\n    var fn = ast.body.length === 0 ? noop :\n             ast.body.length === 1 ? expressions[0] :\n             function(scope, locals) {\n               var lastValue;\n               forEach(expressions, function(exp) {\n                 lastValue = exp(scope, locals);\n               });\n               return lastValue;\n             };\n    if (assign) {\n      fn.assign = function(scope, value, locals) {\n        return assign(scope, locals, value);\n      };\n    }\n    if (inputs) {\n      fn.inputs = inputs;\n    }\n    fn.ast = ast;\nfn.literal = isLiteral(ast);\n    fn.constant = isConstant(ast);\n    return fn;\n  },\n\n  recurse: function(ast, context, create) {\n    var left, right, self = this, args;\n    if (ast.input) {\n      return this.inputs(ast.input, ast.watchId);\n    }\n    switch (ast.type) {\n    case AST.Literal:\n      return this.value(ast.value, context);\n    case AST.UnaryExpression:\n      right = this.recurse(ast.argument);\n      return this['unary' + ast.operator](right, context);\n    case AST.BinaryExpression:\n      left = this.recurse(ast.left);\n      right = this.recurse(ast.right);\n      return this['binary' + ast.operator](left, right, context);\n    case AST.LogicalExpression:\n      left = this.recurse(ast.left);\n      right = this.recurse(ast.right);\n      return this['binary' + ast.operator](left, right, context);\n    case AST.ConditionalExpression:\n      return this['ternary?:'](\n        this.recurse(ast.test),\n        this.recurse(ast.alternate),\n        this.recurse(ast.consequent),\n        context\n      );\n    case AST.Identifier:\n      return self.identifier(ast.name, context, create);\n    case AST.MemberExpression:\n      left = this.recurse(ast.object, false, !!create);\n      if (!ast.computed) {\n        right = ast.property.name;\n      }\n      if (ast.computed) right = this.recurse(ast.property);\n      return ast.computed ?\n        this.computedMember(left, right, context, create) :\n        this.nonComputedMember(left, right, context, create);\n    case AST.CallExpression:\n      args = [];\n      forEach(ast.arguments, function(expr) {\n        args.push(self.recurse(expr));\n      });\n      if (ast.filter) right = this.$filter(ast.callee.name);\n      if (!ast.filter) right = this.recurse(ast.callee, true);\n      return ast.filter ?\n        function(scope, locals, assign, inputs) {\n          var values = [];\n          for (var i = 0; i < args.length; ++i) {\n            values.push(args[i](scope, locals, assign, inputs));\n          }\n          var value = right.apply(undefined, values, inputs);\n          return context ? {context: undefined, name: undefined, value: value} : value;\n        } :\n        function(scope, locals, assign, inputs) {\n          var rhs = right(scope, locals, assign, inputs);\n          var value;\n          if (rhs.value != null) {\n            var values = [];\n            for (var i = 0; i < args.length; ++i) {\n              values.push(args[i](scope, locals, assign, inputs));\n            }\n            value = rhs.value.apply(rhs.context, values);\n          }\n          return context ? {value: value} : value;\n        };\n    case AST.AssignmentExpression:\n      left = this.recurse(ast.left, true, 1);\n      right = this.recurse(ast.right);\n      return function(scope, locals, assign, inputs) {\n        var lhs = left(scope, locals, assign, inputs);\n        var rhs = right(scope, locals, assign, inputs);\n        lhs.context[lhs.name] = rhs;\n        return context ? {value: rhs} : rhs;\n      };\n    case AST.ArrayExpression:\n      args = [];\n      forEach(ast.elements, function(expr) {\n        args.push(self.recurse(expr));\n      });\n      return function(scope, locals, assign, inputs) {\n        var value = [];\n        for (var i = 0; i < args.length; ++i) {\n          value.push(args[i](scope, locals, assign, inputs));\n        }\n        return context ? {value: value} : value;\n      };\n    case AST.ObjectExpression:\n      args = [];\n      forEach(ast.properties, function(property) {\n        if (property.computed) {\n          args.push({key: self.recurse(property.key),\n                     computed: true,\n                     value: self.recurse(property.value)\n          });\n        } else {\n          args.push({key: property.key.type === AST.Identifier ?\n                          property.key.name :\n                          ('' + property.key.value),\n                     computed: false,\n                     value: self.recurse(property.value)\n          });\n        }\n      });\n      return function(scope, locals, assign, inputs) {\n        var value = {};\n        for (var i = 0; i < args.length; ++i) {\n          if (args[i].computed) {\n            value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs);\n          } else {\n            value[args[i].key] = args[i].value(scope, locals, assign, inputs);\n          }\n        }\n        return context ? {value: value} : value;\n      };\n    case AST.ThisExpression:\n      return function(scope) {\n        return context ? {value: scope} : scope;\n      };\n    case AST.LocalsExpression:\n      return function(scope, locals) {\n        return context ? {value: locals} : locals;\n      };\n    case AST.NGValueParameter:\n      return function(scope, locals, assign) {\n        return context ? {value: assign} : assign;\n      };\n    }\n  },\n\n  'unary+': function(argument, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = argument(scope, locals, assign, inputs);\n      if (isDefined(arg)) {\n        arg = +arg;\n      } else {\n        arg = 0;\n      }\n      return context ? {value: arg} : arg;\n    };\n  },\n  'unary-': function(argument, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = argument(scope, locals, assign, inputs);\n      if (isDefined(arg)) {\n        arg = -arg;\n      } else {\n        arg = -0;\n      }\n      return context ? {value: arg} : arg;\n    };\n  },\n  'unary!': function(argument, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = !argument(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary+': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n      var rhs = right(scope, locals, assign, inputs);\n      var arg = plusFn(lhs, rhs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary-': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n      var rhs = right(scope, locals, assign, inputs);\n      var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary*': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary/': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary%': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary===': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary!==': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary==': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      // eslint-disable-next-line eqeqeq\n      var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary!=': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      // eslint-disable-next-line eqeqeq\n      var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary<': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary>': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary<=': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary>=': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary&&': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'binary||': function(left, right, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  'ternary?:': function(test, alternate, consequent, context) {\n    return function(scope, locals, assign, inputs) {\n      var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);\n      return context ? {value: arg} : arg;\n    };\n  },\n  value: function(value, context) {\n    return function() { return context ? {context: undefined, name: undefined, value: value} : value; };\n  },\n  identifier: function(name, context, create) {\n    return function(scope, locals, assign, inputs) {\n      var base = locals && (name in locals) ? locals : scope;\n      if (create && create !== 1 && base && base[name] == null) {\n        base[name] = {};\n      }\n      var value = base ? base[name] : undefined;\n      if (context) {\n        return {context: base, name: name, value: value};\n      } else {\n        return value;\n      }\n    };\n  },\n  computedMember: function(left, right, context, create) {\n    return function(scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n      var rhs;\n      var value;\n      if (lhs != null) {\n        rhs = right(scope, locals, assign, inputs);\n        rhs = getStringValue(rhs);\n        if (create && create !== 1) {\n          if (lhs && !(lhs[rhs])) {\n            lhs[rhs] = {};\n          }\n        }\n        value = lhs[rhs];\n      }\n      if (context) {\n        return {context: lhs, name: rhs, value: value};\n      } else {\n        return value;\n      }\n    };\n  },\n  nonComputedMember: function(left, right, context, create) {\n    return function(scope, locals, assign, inputs) {\n      var lhs = left(scope, locals, assign, inputs);\n      if (create && create !== 1) {\n        if (lhs && lhs[right] == null) {\n          lhs[right] = {};\n        }\n      }\n      var value = lhs != null ? lhs[right] : undefined;\n      if (context) {\n        return {context: lhs, name: right, value: value};\n      } else {\n        return value;\n      }\n    };\n  },\n  inputs: function(input, watchId) {\n    return function(scope, value, locals, inputs) {\n      if (inputs) return inputs[watchId];\n      return input(scope, value, locals);\n    };\n  }\n};\n\n/**\n * @constructor\n */\nvar Parser = function Parser(lexer, $filter, options) {\n  this.lexer = lexer;\n  this.$filter = $filter;\n  this.options = options;\n  this.ast = new AST(lexer, options);\n  this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) :\n                                   new ASTCompiler(this.ast, $filter);\n};\n\nParser.prototype = {\n  constructor: Parser,\n\n  parse: function(text) {\n    return this.astCompiler.compile(text);\n  }\n};\n\nfunction getValueOf(value) {\n  return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);\n}\n\n///////////////////////////////////\n\n/**\n * @ngdoc service\n * @name $parse\n * @kind function\n *\n * @description\n *\n * Converts Angular {@link guide/expression expression} into a function.\n *\n * ```js\n *   var getter = $parse('user.name');\n *   var setter = getter.assign;\n *   var context = {user:{name:'angular'}};\n *   var locals = {user:{name:'local'}};\n *\n *   expect(getter(context)).toEqual('angular');\n *   setter(context, 'newValue');\n *   expect(context.user.name).toEqual('newValue');\n *   expect(getter(context, locals)).toEqual('local');\n * ```\n *\n *\n * @param {string} expression String expression to compile.\n * @returns {function(context, locals)} a function which represents the compiled expression:\n *\n *    * `context`  `{object}`  an object against which any expressions embedded in the strings\n *      are evaluated against (typically a scope object).\n *    * `locals`  `{object=}`  local variables context object, useful for overriding values in\n *      `context`.\n *\n *    The returned function also has the following properties:\n *      * `literal`  `{boolean}`  whether the expression's top-level node is a JavaScript\n *        literal.\n *      * `constant`  `{boolean}`  whether the expression is made entirely of JavaScript\n *        constant literals.\n *      * `assign`  `{?function(context, value)}`  if the expression is assignable, this will be\n *        set to a function to change its value on the given context.\n *\n */\n\n\n/**\n * @ngdoc provider\n * @name $parseProvider\n * @this\n *\n * @description\n * `$parseProvider` can be used for configuring the default behavior of the {@link ng.$parse $parse}\n *  service.\n */\nfunction $ParseProvider() {\n  var cache = createMap();\n  var literals = {\n    'true': true,\n    'false': false,\n    'null': null,\n    'undefined': undefined\n  };\n  var identStart, identContinue;\n\n  /**\n   * @ngdoc method\n   * @name $parseProvider#addLiteral\n   * @description\n   *\n   * Configure $parse service to add literal values that will be present as literal at expressions.\n   *\n   * @param {string} literalName Token for the literal value. The literal name value must be a valid literal name.\n   * @param {*} literalValue Value for this literal. All literal values must be primitives or `undefined`.\n   *\n   **/\n  this.addLiteral = function(literalName, literalValue) {\n    literals[literalName] = literalValue;\n  };\n\n /**\n  * @ngdoc method\n  * @name $parseProvider#setIdentifierFns\n  *\n  * @description\n  *\n  * Allows defining the set of characters that are allowed in Angular expressions. The function\n  * `identifierStart` will get called to know if a given character is a valid character to be the\n  * first character for an identifier. The function `identifierContinue` will get called to know if\n  * a given character is a valid character to be a follow-up identifier character. The functions\n  * `identifierStart` and `identifierContinue` will receive as arguments the single character to be\n  * identifier and the character code point. These arguments will be `string` and `numeric`. Keep in\n  * mind that the `string` parameter can be two characters long depending on the character\n  * representation. It is expected for the function to return `true` or `false`, whether that\n  * character is allowed or not.\n  *\n  * Since this function will be called extensively, keep the implementation of these functions fast,\n  * as the performance of these functions have a direct impact on the expressions parsing speed.\n  *\n  * @param {function=} identifierStart The function that will decide whether the given character is\n  *   a valid identifier start character.\n  * @param {function=} identifierContinue The function that will decide whether the given character is\n  *   a valid identifier continue character.\n  */\n  this.setIdentifierFns = function(identifierStart, identifierContinue) {\n    identStart = identifierStart;\n    identContinue = identifierContinue;\n    return this;\n  };\n\n  this.$get = ['$filter', function($filter) {\n    var noUnsafeEval = csp().noUnsafeEval;\n    var $parseOptions = {\n          csp: noUnsafeEval,\n          literals: copy(literals),\n          isIdentifierStart: isFunction(identStart) && identStart,\n          isIdentifierContinue: isFunction(identContinue) && identContinue\n        };\n    return $parse;\n\n    function $parse(exp, interceptorFn) {\n      var parsedExpression, oneTime, cacheKey;\n\n      switch (typeof exp) {\n        case 'string':\n          exp = exp.trim();\n          cacheKey = exp;\n\n          parsedExpression = cache[cacheKey];\n\n          if (!parsedExpression) {\n            if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {\n              oneTime = true;\n              exp = exp.substring(2);\n            }\n            var lexer = new Lexer($parseOptions);\n            var parser = new Parser(lexer, $filter, $parseOptions);\n            parsedExpression = parser.parse(exp);\n            if (parsedExpression.constant) {\n              parsedExpression.$$watchDelegate = constantWatchDelegate;\n            } else if (oneTime) {\n              parsedExpression.$$watchDelegate = parsedExpression.literal ?\n                  oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;\n            } else if (parsedExpression.inputs) {\n              parsedExpression.$$watchDelegate = inputsWatchDelegate;\n            }\n            cache[cacheKey] = parsedExpression;\n          }\n          return addInterceptor(parsedExpression, interceptorFn);\n\n        case 'function':\n          return addInterceptor(exp, interceptorFn);\n\n        default:\n          return addInterceptor(noop, interceptorFn);\n      }\n    }\n\n    function expressionInputDirtyCheck(newValue, oldValueOfValue) {\n\n      if (newValue == null || oldValueOfValue == null) { // null/undefined\n        return newValue === oldValueOfValue;\n      }\n\n      if (typeof newValue === 'object') {\n\n        // attempt to convert the value to a primitive type\n        // TODO(docs): add a note to docs that by implementing valueOf even objects and arrays can\n        //             be cheaply dirty-checked\n        newValue = getValueOf(newValue);\n\n        if (typeof newValue === 'object') {\n          // objects/arrays are not supported - deep-watching them would be too expensive\n          return false;\n        }\n\n        // fall-through to the primitive equality check\n      }\n\n      //Primitive or NaN\n      // eslint-disable-next-line no-self-compare\n      return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);\n    }\n\n    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {\n      var inputExpressions = parsedExpression.inputs;\n      var lastResult;\n\n      if (inputExpressions.length === 1) {\n        var oldInputValueOf = expressionInputDirtyCheck; // init to something unique so that equals check fails\n        inputExpressions = inputExpressions[0];\n        return scope.$watch(function expressionInputWatch(scope) {\n          var newInputValue = inputExpressions(scope);\n          if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {\n            lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);\n            oldInputValueOf = newInputValue && getValueOf(newInputValue);\n          }\n          return lastResult;\n        }, listener, objectEquality, prettyPrintExpression);\n      }\n\n      var oldInputValueOfValues = [];\n      var oldInputValues = [];\n      for (var i = 0, ii = inputExpressions.length; i < ii; i++) {\n        oldInputValueOfValues[i] = expressionInputDirtyCheck; // init to something unique so that equals check fails\n        oldInputValues[i] = null;\n      }\n\n      return scope.$watch(function expressionInputsWatch(scope) {\n        var changed = false;\n\n        for (var i = 0, ii = inputExpressions.length; i < ii; i++) {\n          var newInputValue = inputExpressions[i](scope);\n          if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {\n            oldInputValues[i] = newInputValue;\n            oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);\n          }\n        }\n\n        if (changed) {\n          lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);\n        }\n\n        return lastResult;\n      }, listener, objectEquality, prettyPrintExpression);\n    }\n\n    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {\n      var unwatch, lastValue;\n      if (parsedExpression.inputs) {\n        unwatch = inputsWatchDelegate(scope, oneTimeListener, objectEquality, parsedExpression, prettyPrintExpression);\n      } else {\n        unwatch = scope.$watch(oneTimeWatch, oneTimeListener, objectEquality);\n      }\n      return unwatch;\n\n      function oneTimeWatch(scope) {\n        return parsedExpression(scope);\n      }\n      function oneTimeListener(value, old, scope) {\n        lastValue = value;\n        if (isFunction(listener)) {\n          listener(value, old, scope);\n        }\n        if (isDefined(value)) {\n          scope.$$postDigest(function() {\n            if (isDefined(lastValue)) {\n              unwatch();\n            }\n          });\n        }\n      }\n    }\n\n    function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {\n      var unwatch, lastValue;\n      unwatch = scope.$watch(function oneTimeWatch(scope) {\n        return parsedExpression(scope);\n      }, function oneTimeListener(value, old, scope) {\n        lastValue = value;\n        if (isFunction(listener)) {\n          listener(value, old, scope);\n        }\n        if (isAllDefined(value)) {\n          scope.$$postDigest(function() {\n            if (isAllDefined(lastValue)) unwatch();\n          });\n        }\n      }, objectEquality);\n\n      return unwatch;\n\n      function isAllDefined(value) {\n        var allDefined = true;\n        forEach(value, function(val) {\n          if (!isDefined(val)) allDefined = false;\n        });\n        return allDefined;\n      }\n    }\n\n    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {\n      var unwatch = scope.$watch(function constantWatch(scope) {\n        unwatch();\n        return parsedExpression(scope);\n      }, listener, objectEquality);\n      return unwatch;\n    }\n\n    function addInterceptor(parsedExpression, interceptorFn) {\n      if (!interceptorFn) return parsedExpression;\n      var watchDelegate = parsedExpression.$$watchDelegate;\n      var useInputs = false;\n\n      var regularWatch =\n          watchDelegate !== oneTimeLiteralWatchDelegate &&\n          watchDelegate !== oneTimeWatchDelegate;\n\n      var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {\n        var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);\n        return interceptorFn(value, scope, locals);\n      } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {\n        var value = parsedExpression(scope, locals, assign, inputs);\n        var result = interceptorFn(value, scope, locals);\n        // we only return the interceptor's result if the\n        // initial value is defined (for bind-once)\n        return isDefined(value) ? result : value;\n      };\n\n      // Propagate $$watchDelegates other then inputsWatchDelegate\n      useInputs = !parsedExpression.inputs;\n      if (parsedExpression.$$watchDelegate &&\n          parsedExpression.$$watchDelegate !== inputsWatchDelegate) {\n        fn.$$watchDelegate = parsedExpression.$$watchDelegate;\n        fn.inputs = parsedExpression.inputs;\n      } else if (!interceptorFn.$stateful) {\n        // If there is an interceptor, but no watchDelegate then treat the interceptor like\n        // we treat filters - it is assumed to be a pure function unless flagged with $stateful\n        fn.$$watchDelegate = inputsWatchDelegate;\n        fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];\n      }\n\n      return fn;\n    }\n  }];\n}\n\nexports.Lexer = Lexer;\nexports.Parser = Parser;\n\n\n","var MILLISECONDS_IN_MINUTE = 60000\n\n/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\nmodule.exports = function getTimezoneOffsetInMilliseconds (dirtyDate) {\n  var date = new Date(dirtyDate.getTime())\n  var baseTimezoneOffset = date.getTimezoneOffset()\n  date.setSeconds(0, 0)\n  var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE\n\n  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset\n}\n","var startOfDay = require('../start_of_day/index.js')\n\nvar MILLISECONDS_IN_MINUTE = 60000\nvar MILLISECONDS_IN_DAY = 86400000\n\n/**\n * @category Day Helpers\n * @summary Get the number of calendar days between the given dates.\n *\n * @description\n * Get the number of calendar days between the given dates.\n *\n * @param {Date|String|Number} dateLeft - the later date\n * @param {Date|String|Number} dateRight - the earlier date\n * @returns {Number} the number of calendar days\n *\n * @example\n * // How many calendar days are between\n * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?\n * var result = differenceInCalendarDays(\n *   new Date(2012, 6, 2, 0, 0),\n *   new Date(2011, 6, 2, 23, 0)\n * )\n * //=> 366\n */\nfunction differenceInCalendarDays (dirtyDateLeft, dirtyDateRight) {\n  var startOfDayLeft = startOfDay(dirtyDateLeft)\n  var startOfDayRight = startOfDay(dirtyDateRight)\n\n  var timestampLeft = startOfDayLeft.getTime() -\n    startOfDayLeft.getTimezoneOffset() * MILLISECONDS_IN_MINUTE\n  var timestampRight = startOfDayRight.getTime() -\n    startOfDayRight.getTimezoneOffset() * MILLISECONDS_IN_MINUTE\n\n  // Round the number of days to the nearest integer\n  // because the number of milliseconds in a day is not constant\n  // (e.g. it's different in the day of the daylight saving time clock shift)\n  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY)\n}\n\nmodule.exports = differenceInCalendarDays\n","var getDayOfYear = require('../get_day_of_year/index.js')\nvar getISOWeek = require('../get_iso_week/index.js')\nvar getISOYear = require('../get_iso_year/index.js')\nvar parse = require('../parse/index.js')\nvar isValid = require('../is_valid/index.js')\nvar enLocale = require('../locale/en/index.js')\n\n/**\n * @category Common Helpers\n * @summary Format the date.\n *\n * @description\n * Return the formatted date string in the given format.\n *\n * Accepted tokens:\n * | Unit                    | Token | Result examples                  |\n * |-------------------------|-------|----------------------------------|\n * | Month                   | M     | 1, 2, ..., 12                    |\n * |                         | Mo    | 1st, 2nd, ..., 12th              |\n * |                         | MM    | 01, 02, ..., 12                  |\n * |                         | MMM   | Jan, Feb, ..., Dec               |\n * |                         | MMMM  | January, February, ..., December |\n * | Quarter                 | Q     | 1, 2, 3, 4                       |\n * |                         | Qo    | 1st, 2nd, 3rd, 4th               |\n * | Day of month            | D     | 1, 2, ..., 31                    |\n * |                         | Do    | 1st, 2nd, ..., 31st              |\n * |                         | DD    | 01, 02, ..., 31                  |\n * | Day of year             | DDD   | 1, 2, ..., 366                   |\n * |                         | DDDo  | 1st, 2nd, ..., 366th             |\n * |                         | DDDD  | 001, 002, ..., 366               |\n * | Day of week             | d     | 0, 1, ..., 6                     |\n * |                         | do    | 0th, 1st, ..., 6th               |\n * |                         | dd    | Su, Mo, ..., Sa                  |\n * |                         | ddd   | Sun, Mon, ..., Sat               |\n * |                         | dddd  | Sunday, Monday, ..., Saturday    |\n * | Day of ISO week         | E     | 1, 2, ..., 7                     |\n * | ISO week                | W     | 1, 2, ..., 53                    |\n * |                         | Wo    | 1st, 2nd, ..., 53rd              |\n * |                         | WW    | 01, 02, ..., 53                  |\n * | Year                    | YY    | 00, 01, ..., 99                  |\n * |                         | YYYY  | 1900, 1901, ..., 2099            |\n * | ISO week-numbering year | GG    | 00, 01, ..., 99                  |\n * |                         | GGGG  | 1900, 1901, ..., 2099            |\n * | AM/PM                   | A     | AM, PM                           |\n * |                         | a     | am, pm                           |\n * |                         | aa    | a.m., p.m.                       |\n * | Hour                    | H     | 0, 1, ... 23                     |\n * |                         | HH    | 00, 01, ... 23                   |\n * |                         | h     | 1, 2, ..., 12                    |\n * |                         | hh    | 01, 02, ..., 12                  |\n * | Minute                  | m     | 0, 1, ..., 59                    |\n * |                         | mm    | 00, 01, ..., 59                  |\n * | Second                  | s     | 0, 1, ..., 59                    |\n * |                         | ss    | 00, 01, ..., 59                  |\n * | 1/10 of second          | S     | 0, 1, ..., 9                     |\n * | 1/100 of second         | SS    | 00, 01, ..., 99                  |\n * | Millisecond             | SSS   | 000, 001, ..., 999               |\n * | Timezone                | Z     | -01:00, +00:00, ... +12:00       |\n * |                         | ZZ    | -0100, +0000, ..., +1200         |\n * | Seconds timestamp       | X     | 512969520                        |\n * | Milliseconds timestamp  | x     | 512969520900                     |\n *\n * The characters wrapped in square brackets are escaped.\n *\n * The result may vary by locale.\n *\n * @param {Date|String|Number} date - the original date\n * @param {String} [format='YYYY-MM-DDTHH:mm:ss.SSSZ'] - the string of tokens\n * @param {Object} [options] - the object with options\n * @param {Object} [options.locale=enLocale] - the locale object\n * @returns {String} the formatted date string\n *\n * @example\n * // Represent 11 February 2014 in middle-endian format:\n * var result = format(\n *   new Date(2014, 1, 11),\n *   'MM/DD/YYYY'\n * )\n * //=> '02/11/2014'\n *\n * @example\n * // Represent 2 July 2014 in Esperanto:\n * var eoLocale = require('date-fns/locale/eo')\n * var result = format(\n *   new Date(2014, 6, 2),\n *   'Do [de] MMMM YYYY',\n *   {locale: eoLocale}\n * )\n * //=> '2-a de julio 2014'\n */\nfunction format (dirtyDate, dirtyFormatStr, dirtyOptions) {\n  var formatStr = dirtyFormatStr ? String(dirtyFormatStr) : 'YYYY-MM-DDTHH:mm:ss.SSSZ'\n  var options = dirtyOptions || {}\n\n  var locale = options.locale\n  var localeFormatters = enLocale.format.formatters\n  var formattingTokensRegExp = enLocale.format.formattingTokensRegExp\n  if (locale && locale.format && locale.format.formatters) {\n    localeFormatters = locale.format.formatters\n\n    if (locale.format.formattingTokensRegExp) {\n      formattingTokensRegExp = locale.format.formattingTokensRegExp\n    }\n  }\n\n  var date = parse(dirtyDate)\n\n  if (!isValid(date)) {\n    return 'Invalid Date'\n  }\n\n  var formatFn = buildFormatFn(formatStr, localeFormatters, formattingTokensRegExp)\n\n  return formatFn(date)\n}\n\nvar formatters = {\n  // Month: 1, 2, ..., 12\n  'M': function (date) {\n    return date.getMonth() + 1\n  },\n\n  // Month: 01, 02, ..., 12\n  'MM': function (date) {\n    return addLeadingZeros(date.getMonth() + 1, 2)\n  },\n\n  // Quarter: 1, 2, 3, 4\n  'Q': function (date) {\n    return Math.ceil((date.getMonth() + 1) / 3)\n  },\n\n  // Day of month: 1, 2, ..., 31\n  'D': function (date) {\n    return date.getDate()\n  },\n\n  // Day of month: 01, 02, ..., 31\n  'DD': function (date) {\n    return addLeadingZeros(date.getDate(), 2)\n  },\n\n  // Day of year: 1, 2, ..., 366\n  'DDD': function (date) {\n    return getDayOfYear(date)\n  },\n\n  // Day of year: 001, 002, ..., 366\n  'DDDD': function (date) {\n    return addLeadingZeros(getDayOfYear(date), 3)\n  },\n\n  // Day of week: 0, 1, ..., 6\n  'd': function (date) {\n    return date.getDay()\n  },\n\n  // Day of ISO week: 1, 2, ..., 7\n  'E': function (date) {\n    return date.getDay() || 7\n  },\n\n  // ISO week: 1, 2, ..., 53\n  'W': function (date) {\n    return getISOWeek(date)\n  },\n\n  // ISO week: 01, 02, ..., 53\n  'WW': function (date) {\n    return addLeadingZeros(getISOWeek(date), 2)\n  },\n\n  // Year: 00, 01, ..., 99\n  'YY': function (date) {\n    return addLeadingZeros(date.getFullYear(), 4).substr(2)\n  },\n\n  // Year: 1900, 1901, ..., 2099\n  'YYYY': function (date) {\n    return addLeadingZeros(date.getFullYear(), 4)\n  },\n\n  // ISO week-numbering year: 00, 01, ..., 99\n  'GG': function (date) {\n    return String(getISOYear(date)).substr(2)\n  },\n\n  // ISO week-numbering year: 1900, 1901, ..., 2099\n  'GGGG': function (date) {\n    return getISOYear(date)\n  },\n\n  // Hour: 0, 1, ... 23\n  'H': function (date) {\n    return date.getHours()\n  },\n\n  // Hour: 00, 01, ..., 23\n  'HH': function (date) {\n    return addLeadingZeros(date.getHours(), 2)\n  },\n\n  // Hour: 1, 2, ..., 12\n  'h': function (date) {\n    var hours = date.getHours()\n    if (hours === 0) {\n      return 12\n    } else if (hours > 12) {\n      return hours % 12\n    } else {\n      return hours\n    }\n  },\n\n  // Hour: 01, 02, ..., 12\n  'hh': function (date) {\n    return addLeadingZeros(formatters['h'](date), 2)\n  },\n\n  // Minute: 0, 1, ..., 59\n  'm': function (date) {\n    return date.getMinutes()\n  },\n\n  // Minute: 00, 01, ..., 59\n  'mm': function (date) {\n    return addLeadingZeros(date.getMinutes(), 2)\n  },\n\n  // Second: 0, 1, ..., 59\n  's': function (date) {\n    return date.getSeconds()\n  },\n\n  // Second: 00, 01, ..., 59\n  'ss': function (date) {\n    return addLeadingZeros(date.getSeconds(), 2)\n  },\n\n  // 1/10 of second: 0, 1, ..., 9\n  'S': function (date) {\n    return Math.floor(date.getMilliseconds() / 100)\n  },\n\n  // 1/100 of second: 00, 01, ..., 99\n  'SS': function (date) {\n    return addLeadingZeros(Math.floor(date.getMilliseconds() / 10), 2)\n  },\n\n  // Millisecond: 000, 001, ..., 999\n  'SSS': function (date) {\n    return addLeadingZeros(date.getMilliseconds(), 3)\n  },\n\n  // Timezone: -01:00, +00:00, ... +12:00\n  'Z': function (date) {\n    return formatTimezone(date.getTimezoneOffset(), ':')\n  },\n\n  // Timezone: -0100, +0000, ... +1200\n  'ZZ': function (date) {\n    return formatTimezone(date.getTimezoneOffset())\n  },\n\n  // Seconds timestamp: 512969520\n  'X': function (date) {\n    return Math.floor(date.getTime() / 1000)\n  },\n\n  // Milliseconds timestamp: 512969520900\n  'x': function (date) {\n    return date.getTime()\n  }\n}\n\nfunction buildFormatFn (formatStr, localeFormatters, formattingTokensRegExp) {\n  var array = formatStr.match(formattingTokensRegExp)\n  var length = array.length\n\n  var i\n  var formatter\n  for (i = 0; i < length; i++) {\n    formatter = localeFormatters[array[i]] || formatters[array[i]]\n    if (formatter) {\n      array[i] = formatter\n    } else {\n      array[i] = removeFormattingTokens(array[i])\n    }\n  }\n\n  return function (date) {\n    var output = ''\n    for (var i = 0; i < length; i++) {\n      if (array[i] instanceof Function) {\n        output += array[i](date, formatters)\n      } else {\n        output += array[i]\n      }\n    }\n    return output\n  }\n}\n\nfunction removeFormattingTokens (input) {\n  if (input.match(/\\[[\\s\\S]/)) {\n    return input.replace(/^\\[|]$/g, '')\n  }\n  return input.replace(/\\\\/g, '')\n}\n\nfunction formatTimezone (offset, delimeter) {\n  delimeter = delimeter || ''\n  var sign = offset > 0 ? '-' : '+'\n  var absOffset = Math.abs(offset)\n  var hours = Math.floor(absOffset / 60)\n  var minutes = absOffset % 60\n  return sign + addLeadingZeros(hours, 2) + delimeter + addLeadingZeros(minutes, 2)\n}\n\nfunction addLeadingZeros (number, targetLength) {\n  var output = Math.abs(number).toString()\n  while (output.length < targetLength) {\n    output = '0' + output\n  }\n  return output\n}\n\nmodule.exports = format\n","var parse = require('../parse/index.js')\nvar startOfYear = require('../start_of_year/index.js')\nvar differenceInCalendarDays = require('../difference_in_calendar_days/index.js')\n\n/**\n * @category Day Helpers\n * @summary Get the day of the year of the given date.\n *\n * @description\n * Get the day of the year of the given date.\n *\n * @param {Date|String|Number} date - the given date\n * @returns {Number} the day of year\n *\n * @example\n * // Which day of the year is 2 July 2014?\n * var result = getDayOfYear(new Date(2014, 6, 2))\n * //=> 183\n */\nfunction getDayOfYear (dirtyDate) {\n  var date = parse(dirtyDate)\n  var diff = differenceInCalendarDays(date, startOfYear(date))\n  var dayOfYear = diff + 1\n  return dayOfYear\n}\n\nmodule.exports = getDayOfYear\n","var parse = require('../parse/index.js')\nvar startOfISOWeek = require('../start_of_iso_week/index.js')\nvar startOfISOYear = require('../start_of_iso_year/index.js')\n\nvar MILLISECONDS_IN_WEEK = 604800000\n\n/**\n * @category ISO Week Helpers\n * @summary Get the ISO week of the given date.\n *\n * @description\n * Get the ISO week of the given date.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @param {Date|String|Number} date - the given date\n * @returns {Number} the ISO week\n *\n * @example\n * // Which week of the ISO-week numbering year is 2 January 2005?\n * var result = getISOWeek(new Date(2005, 0, 2))\n * //=> 53\n */\nfunction getISOWeek (dirtyDate) {\n  var date = parse(dirtyDate)\n  var diff = startOfISOWeek(date).getTime() - startOfISOYear(date).getTime()\n\n  // Round the number of days to the nearest integer\n  // because the number of milliseconds in a week is not constant\n  // (e.g. it's different in the week of the daylight saving time clock shift)\n  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1\n}\n\nmodule.exports = getISOWeek\n","var parse = require('../parse/index.js')\nvar startOfISOWeek = require('../start_of_iso_week/index.js')\n\n/**\n * @category ISO Week-Numbering Year Helpers\n * @summary Get the ISO week-numbering year of the given date.\n *\n * @description\n * Get the ISO week-numbering year of the given date,\n * which always starts 3 days before the year's first Thursday.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @param {Date|String|Number} date - the given date\n * @returns {Number} the ISO week-numbering year\n *\n * @example\n * // Which ISO-week numbering year is 2 January 2005?\n * var result = getISOYear(new Date(2005, 0, 2))\n * //=> 2004\n */\nfunction getISOYear (dirtyDate) {\n  var date = parse(dirtyDate)\n  var year = date.getFullYear()\n\n  var fourthOfJanuaryOfNextYear = new Date(0)\n  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4)\n  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0)\n  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear)\n\n  var fourthOfJanuaryOfThisYear = new Date(0)\n  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4)\n  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0)\n  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear)\n\n  if (date.getTime() >= startOfNextYear.getTime()) {\n    return year + 1\n  } else if (date.getTime() >= startOfThisYear.getTime()) {\n    return year\n  } else {\n    return year - 1\n  }\n}\n\nmodule.exports = getISOYear\n","/**\n * @category Common Helpers\n * @summary Is the given argument an instance of Date?\n *\n * @description\n * Is the given argument an instance of Date?\n *\n * @param {*} argument - the argument to check\n * @returns {Boolean} the given argument is an instance of Date\n *\n * @example\n * // Is 'mayonnaise' a Date?\n * var result = isDate('mayonnaise')\n * //=> false\n */\nfunction isDate (argument) {\n  return argument instanceof Date\n}\n\nmodule.exports = isDate\n","var isDate = require('../is_date/index.js')\n\n/**\n * @category Common Helpers\n * @summary Is the given date valid?\n *\n * @description\n * Returns false if argument is Invalid Date and true otherwise.\n * Invalid Date is a Date, whose time value is NaN.\n *\n * Time value of Date: http://es5.github.io/#x15.9.1.1\n *\n * @param {Date} date - the date to check\n * @returns {Boolean} the date is valid\n * @throws {TypeError} argument must be an instance of Date\n *\n * @example\n * // For the valid date:\n * var result = isValid(new Date(2014, 1, 31))\n * //=> true\n *\n * @example\n * // For the invalid date:\n * var result = isValid(new Date(''))\n * //=> false\n */\nfunction isValid (dirtyDate) {\n  if (isDate(dirtyDate)) {\n    return !isNaN(dirtyDate)\n  } else {\n    throw new TypeError(toString.call(dirtyDate) + ' is not an instance of Date')\n  }\n}\n\nmodule.exports = isValid\n","var commonFormatterKeys = [\n  'M', 'MM', 'Q', 'D', 'DD', 'DDD', 'DDDD', 'd',\n  'E', 'W', 'WW', 'YY', 'YYYY', 'GG', 'GGGG',\n  'H', 'HH', 'h', 'hh', 'm', 'mm',\n  's', 'ss', 'S', 'SS', 'SSS',\n  'Z', 'ZZ', 'X', 'x'\n]\n\nfunction buildFormattingTokensRegExp (formatters) {\n  var formatterKeys = []\n  for (var key in formatters) {\n    if (formatters.hasOwnProperty(key)) {\n      formatterKeys.push(key)\n    }\n  }\n\n  var formattingTokens = commonFormatterKeys\n    .concat(formatterKeys)\n    .sort()\n    .reverse()\n  var formattingTokensRegExp = new RegExp(\n    '(\\\\[[^\\\\[]*\\\\])|(\\\\\\\\)?' + '(' + formattingTokens.join('|') + '|.)', 'g'\n  )\n\n  return formattingTokensRegExp\n}\n\nmodule.exports = buildFormattingTokensRegExp\n","function buildDistanceInWordsLocale () {\n  var distanceInWordsLocale = {\n    lessThanXSeconds: {\n      one: 'less than a second',\n      other: 'less than {{count}} seconds'\n    },\n\n    xSeconds: {\n      one: '1 second',\n      other: '{{count}} seconds'\n    },\n\n    halfAMinute: 'half a minute',\n\n    lessThanXMinutes: {\n      one: 'less than a minute',\n      other: 'less than {{count}} minutes'\n    },\n\n    xMinutes: {\n      one: '1 minute',\n      other: '{{count}} minutes'\n    },\n\n    aboutXHours: {\n      one: 'about 1 hour',\n      other: 'about {{count}} hours'\n    },\n\n    xHours: {\n      one: '1 hour',\n      other: '{{count}} hours'\n    },\n\n    xDays: {\n      one: '1 day',\n      other: '{{count}} days'\n    },\n\n    aboutXMonths: {\n      one: 'about 1 month',\n      other: 'about {{count}} months'\n    },\n\n    xMonths: {\n      one: '1 month',\n      other: '{{count}} months'\n    },\n\n    aboutXYears: {\n      one: 'about 1 year',\n      other: 'about {{count}} years'\n    },\n\n    xYears: {\n      one: '1 year',\n      other: '{{count}} years'\n    },\n\n    overXYears: {\n      one: 'over 1 year',\n      other: 'over {{count}} years'\n    },\n\n    almostXYears: {\n      one: 'almost 1 year',\n      other: 'almost {{count}} years'\n    }\n  }\n\n  function localize (token, count, options) {\n    options = options || {}\n\n    var result\n    if (typeof distanceInWordsLocale[token] === 'string') {\n      result = distanceInWordsLocale[token]\n    } else if (count === 1) {\n      result = distanceInWordsLocale[token].one\n    } else {\n      result = distanceInWordsLocale[token].other.replace('{{count}}', count)\n    }\n\n    if (options.addSuffix) {\n      if (options.comparison > 0) {\n        return 'in ' + result\n      } else {\n        return result + ' ago'\n      }\n    }\n\n    return result\n  }\n\n  return {\n    localize: localize\n  }\n}\n\nmodule.exports = buildDistanceInWordsLocale\n","var buildFormattingTokensRegExp = require('../../_lib/build_formatting_tokens_reg_exp/index.js')\n\nfunction buildFormatLocale () {\n  // Note: in English, the names of days of the week and months are capitalized.\n  // If you are making a new locale based on this one, check if the same is true for the language you're working on.\n  // Generally, formatted dates should look like they are in the middle of a sentence,\n  // e.g. in Spanish language the weekdays and months should be in the lowercase.\n  var months3char = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n  var monthsFull = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']\n  var weekdays2char = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']\n  var weekdays3char = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\n  var weekdaysFull = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n  var meridiemUppercase = ['AM', 'PM']\n  var meridiemLowercase = ['am', 'pm']\n  var meridiemFull = ['a.m.', 'p.m.']\n\n  var formatters = {\n    // Month: Jan, Feb, ..., Dec\n    'MMM': function (date) {\n      return months3char[date.getMonth()]\n    },\n\n    // Month: January, February, ..., December\n    'MMMM': function (date) {\n      return monthsFull[date.getMonth()]\n    },\n\n    // Day of week: Su, Mo, ..., Sa\n    'dd': function (date) {\n      return weekdays2char[date.getDay()]\n    },\n\n    // Day of week: Sun, Mon, ..., Sat\n    'ddd': function (date) {\n      return weekdays3char[date.getDay()]\n    },\n\n    // Day of week: Sunday, Monday, ..., Saturday\n    'dddd': function (date) {\n      return weekdaysFull[date.getDay()]\n    },\n\n    // AM, PM\n    'A': function (date) {\n      return (date.getHours() / 12) >= 1 ? meridiemUppercase[1] : meridiemUppercase[0]\n    },\n\n    // am, pm\n    'a': function (date) {\n      return (date.getHours() / 12) >= 1 ? meridiemLowercase[1] : meridiemLowercase[0]\n    },\n\n    // a.m., p.m.\n    'aa': function (date) {\n      return (date.getHours() / 12) >= 1 ? meridiemFull[1] : meridiemFull[0]\n    }\n  }\n\n  // Generate ordinal version of formatters: M -> Mo, D -> Do, etc.\n  var ordinalFormatters = ['M', 'D', 'DDD', 'd', 'Q', 'W']\n  ordinalFormatters.forEach(function (formatterToken) {\n    formatters[formatterToken + 'o'] = function (date, formatters) {\n      return ordinal(formatters[formatterToken](date))\n    }\n  })\n\n  return {\n    formatters: formatters,\n    formattingTokensRegExp: buildFormattingTokensRegExp(formatters)\n  }\n}\n\nfunction ordinal (number) {\n  var rem100 = number % 100\n  if (rem100 > 20 || rem100 < 10) {\n    switch (rem100 % 10) {\n      case 1:\n        return number + 'st'\n      case 2:\n        return number + 'nd'\n      case 3:\n        return number + 'rd'\n    }\n  }\n  return number + 'th'\n}\n\nmodule.exports = buildFormatLocale\n","var buildDistanceInWordsLocale = require('./build_distance_in_words_locale/index.js')\nvar buildFormatLocale = require('./build_format_locale/index.js')\n\n/**\n * @category Locales\n * @summary English locale.\n */\nmodule.exports = {\n  distanceInWords: buildDistanceInWordsLocale(),\n  format: buildFormatLocale()\n}\n","var getTimezoneOffsetInMilliseconds = require('../_lib/getTimezoneOffsetInMilliseconds/index.js')\nvar isDate = require('../is_date/index.js')\n\nvar MILLISECONDS_IN_HOUR = 3600000\nvar MILLISECONDS_IN_MINUTE = 60000\nvar DEFAULT_ADDITIONAL_DIGITS = 2\n\nvar parseTokenDateTimeDelimeter = /[T ]/\nvar parseTokenPlainTime = /:/\n\n// year tokens\nvar parseTokenYY = /^(\\d{2})$/\nvar parseTokensYYY = [\n  /^([+-]\\d{2})$/, // 0 additional digits\n  /^([+-]\\d{3})$/, // 1 additional digit\n  /^([+-]\\d{4})$/ // 2 additional digits\n]\n\nvar parseTokenYYYY = /^(\\d{4})/\nvar parseTokensYYYYY = [\n  /^([+-]\\d{4})/, // 0 additional digits\n  /^([+-]\\d{5})/, // 1 additional digit\n  /^([+-]\\d{6})/ // 2 additional digits\n]\n\n// date tokens\nvar parseTokenMM = /^-(\\d{2})$/\nvar parseTokenDDD = /^-?(\\d{3})$/\nvar parseTokenMMDD = /^-?(\\d{2})-?(\\d{2})$/\nvar parseTokenWww = /^-?W(\\d{2})$/\nvar parseTokenWwwD = /^-?W(\\d{2})-?(\\d{1})$/\n\n// time tokens\nvar parseTokenHH = /^(\\d{2}([.,]\\d*)?)$/\nvar parseTokenHHMM = /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/\nvar parseTokenHHMMSS = /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/\n\n// timezone tokens\nvar parseTokenTimezone = /([Z+-].*)$/\nvar parseTokenTimezoneZ = /^(Z)$/\nvar parseTokenTimezoneHH = /^([+-])(\\d{2})$/\nvar parseTokenTimezoneHHMM = /^([+-])(\\d{2}):?(\\d{2})$/\n\n/**\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If an argument is a string, the function tries to parse it.\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n *\n * If all above fails, the function passes the given argument to Date constructor.\n *\n * @param {Date|String|Number} argument - the value to convert\n * @param {Object} [options] - the object with options\n * @param {0 | 1 | 2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @returns {Date} the parsed date in the local time zone\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * var result = parse('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Parse string '+02014101',\n * // if the additional number of digits in the extended year format is 1:\n * var result = parse('+02014101', {additionalDigits: 1})\n * //=> Fri Apr 11 2014 00:00:00\n */\nfunction parse (argument, dirtyOptions) {\n  if (isDate(argument)) {\n    // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n    return new Date(argument.getTime())\n  } else if (typeof argument !== 'string') {\n    return new Date(argument)\n  }\n\n  var options = dirtyOptions || {}\n  var additionalDigits = options.additionalDigits\n  if (additionalDigits == null) {\n    additionalDigits = DEFAULT_ADDITIONAL_DIGITS\n  } else {\n    additionalDigits = Number(additionalDigits)\n  }\n\n  var dateStrings = splitDateString(argument)\n\n  var parseYearResult = parseYear(dateStrings.date, additionalDigits)\n  var year = parseYearResult.year\n  var restDateString = parseYearResult.restDateString\n\n  var date = parseDate(restDateString, year)\n\n  if (date) {\n    var timestamp = date.getTime()\n    var time = 0\n    var offset\n\n    if (dateStrings.time) {\n      time = parseTime(dateStrings.time)\n    }\n\n    if (dateStrings.timezone) {\n      offset = parseTimezone(dateStrings.timezone) * MILLISECONDS_IN_MINUTE\n    } else {\n      var fullTime = timestamp + time\n      var fullTimeDate = new Date(fullTime)\n\n      offset = getTimezoneOffsetInMilliseconds(fullTimeDate)\n\n      // Adjust time when it's coming from DST\n      var fullTimeDateNextDay = new Date(fullTime)\n      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1)\n      var offsetDiff =\n        getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) -\n        getTimezoneOffsetInMilliseconds(fullTimeDate)\n      if (offsetDiff > 0) {\n        offset += offsetDiff\n      }\n    }\n\n    return new Date(timestamp + time + offset)\n  } else {\n    return new Date(argument)\n  }\n}\n\nfunction splitDateString (dateString) {\n  var dateStrings = {}\n  var array = dateString.split(parseTokenDateTimeDelimeter)\n  var timeString\n\n  if (parseTokenPlainTime.test(array[0])) {\n    dateStrings.date = null\n    timeString = array[0]\n  } else {\n    dateStrings.date = array[0]\n    timeString = array[1]\n  }\n\n  if (timeString) {\n    var token = parseTokenTimezone.exec(timeString)\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], '')\n      dateStrings.timezone = token[1]\n    } else {\n      dateStrings.time = timeString\n    }\n  }\n\n  return dateStrings\n}\n\nfunction parseYear (dateString, additionalDigits) {\n  var parseTokenYYY = parseTokensYYY[additionalDigits]\n  var parseTokenYYYYY = parseTokensYYYYY[additionalDigits]\n\n  var token\n\n  // YYYY or YYYYY\n  token = parseTokenYYYY.exec(dateString) || parseTokenYYYYY.exec(dateString)\n  if (token) {\n    var yearString = token[1]\n    return {\n      year: parseInt(yearString, 10),\n      restDateString: dateString.slice(yearString.length)\n    }\n  }\n\n  // YY or YYY\n  token = parseTokenYY.exec(dateString) || parseTokenYYY.exec(dateString)\n  if (token) {\n    var centuryString = token[1]\n    return {\n      year: parseInt(centuryString, 10) * 100,\n      restDateString: dateString.slice(centuryString.length)\n    }\n  }\n\n  // Invalid ISO-formatted year\n  return {\n    year: null\n  }\n}\n\nfunction parseDate (dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) {\n    return null\n  }\n\n  var token\n  var date\n  var month\n  var week\n\n  // YYYY\n  if (dateString.length === 0) {\n    date = new Date(0)\n    date.setUTCFullYear(year)\n    return date\n  }\n\n  // YYYY-MM\n  token = parseTokenMM.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    date.setUTCFullYear(year, month)\n    return date\n  }\n\n  // YYYY-DDD or YYYYDDD\n  token = parseTokenDDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    var dayOfYear = parseInt(token[1], 10)\n    date.setUTCFullYear(year, 0, dayOfYear)\n    return date\n  }\n\n  // YYYY-MM-DD or YYYYMMDD\n  token = parseTokenMMDD.exec(dateString)\n  if (token) {\n    date = new Date(0)\n    month = parseInt(token[1], 10) - 1\n    var day = parseInt(token[2], 10)\n    date.setUTCFullYear(year, month, day)\n    return date\n  }\n\n  // YYYY-Www or YYYYWww\n  token = parseTokenWww.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    return dayOfISOYear(year, week)\n  }\n\n  // YYYY-Www-D or YYYYWwwD\n  token = parseTokenWwwD.exec(dateString)\n  if (token) {\n    week = parseInt(token[1], 10) - 1\n    var dayOfWeek = parseInt(token[2], 10) - 1\n    return dayOfISOYear(year, week, dayOfWeek)\n  }\n\n  // Invalid ISO-formatted date\n  return null\n}\n\nfunction parseTime (timeString) {\n  var token\n  var hours\n  var minutes\n\n  // hh\n  token = parseTokenHH.exec(timeString)\n  if (token) {\n    hours = parseFloat(token[1].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR\n  }\n\n  // hh:mm or hhmm\n  token = parseTokenHHMM.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseFloat(token[2].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE\n  }\n\n  // hh:mm:ss or hhmmss\n  token = parseTokenHHMMSS.exec(timeString)\n  if (token) {\n    hours = parseInt(token[1], 10)\n    minutes = parseInt(token[2], 10)\n    var seconds = parseFloat(token[3].replace(',', '.'))\n    return (hours % 24) * MILLISECONDS_IN_HOUR +\n      minutes * MILLISECONDS_IN_MINUTE +\n      seconds * 1000\n  }\n\n  // Invalid ISO-formatted time\n  return null\n}\n\nfunction parseTimezone (timezoneString) {\n  var token\n  var absoluteOffset\n\n  // Z\n  token = parseTokenTimezoneZ.exec(timezoneString)\n  if (token) {\n    return 0\n  }\n\n  // hh\n  token = parseTokenTimezoneHH.exec(timezoneString)\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60\n    return (token[1] === '+') ? -absoluteOffset : absoluteOffset\n  }\n\n  // hh:mm or hhmm\n  token = parseTokenTimezoneHHMM.exec(timezoneString)\n  if (token) {\n    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10)\n    return (token[1] === '+') ? -absoluteOffset : absoluteOffset\n  }\n\n  return 0\n}\n\nfunction dayOfISOYear (isoYear, week, day) {\n  week = week || 0\n  day = day || 0\n  var date = new Date(0)\n  date.setUTCFullYear(isoYear, 0, 4)\n  var fourthOfJanuaryDay = date.getUTCDay() || 7\n  var diff = week * 7 + day + 1 - fourthOfJanuaryDay\n  date.setUTCDate(date.getUTCDate() + diff)\n  return date\n}\n\nmodule.exports = parse\n","var parse = require('../parse/index.js')\n\n/**\n * @category Day Helpers\n * @summary Return the start of a day for the given date.\n *\n * @description\n * Return the start of a day for the given date.\n * The result will be in the local timezone.\n *\n * @param {Date|String|Number} date - the original date\n * @returns {Date} the start of a day\n *\n * @example\n * // The start of a day for 2 September 2014 11:55:00:\n * var result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Tue Sep 02 2014 00:00:00\n */\nfunction startOfDay (dirtyDate) {\n  var date = parse(dirtyDate)\n  date.setHours(0, 0, 0, 0)\n  return date\n}\n\nmodule.exports = startOfDay\n","var startOfWeek = require('../start_of_week/index.js')\n\n/**\n * @category ISO Week Helpers\n * @summary Return the start of an ISO week for the given date.\n *\n * @description\n * Return the start of an ISO week for the given date.\n * The result will be in the local timezone.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @param {Date|String|Number} date - the original date\n * @returns {Date} the start of an ISO week\n *\n * @example\n * // The start of an ISO week for 2 September 2014 11:55:00:\n * var result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Mon Sep 01 2014 00:00:00\n */\nfunction startOfISOWeek (dirtyDate) {\n  return startOfWeek(dirtyDate, {weekStartsOn: 1})\n}\n\nmodule.exports = startOfISOWeek\n","var getISOYear = require('../get_iso_year/index.js')\nvar startOfISOWeek = require('../start_of_iso_week/index.js')\n\n/**\n * @category ISO Week-Numbering Year Helpers\n * @summary Return the start of an ISO week-numbering year for the given date.\n *\n * @description\n * Return the start of an ISO week-numbering year,\n * which always starts 3 days before the year's first Thursday.\n * The result will be in the local timezone.\n *\n * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date\n *\n * @param {Date|String|Number} date - the original date\n * @returns {Date} the start of an ISO year\n *\n * @example\n * // The start of an ISO week-numbering year for 2 July 2005:\n * var result = startOfISOYear(new Date(2005, 6, 2))\n * //=> Mon Jan 03 2005 00:00:00\n */\nfunction startOfISOYear (dirtyDate) {\n  var year = getISOYear(dirtyDate)\n  var fourthOfJanuary = new Date(0)\n  fourthOfJanuary.setFullYear(year, 0, 4)\n  fourthOfJanuary.setHours(0, 0, 0, 0)\n  var date = startOfISOWeek(fourthOfJanuary)\n  return date\n}\n\nmodule.exports = startOfISOYear\n","var parse = require('../parse/index.js')\n\n/**\n * @category Week Helpers\n * @summary Return the start of a week for the given date.\n *\n * @description\n * Return the start of a week for the given date.\n * The result will be in the local timezone.\n *\n * @param {Date|String|Number} date - the original date\n * @param {Object} [options] - the object with options\n * @param {Number} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)\n * @returns {Date} the start of a week\n *\n * @example\n * // The start of a week for 2 September 2014 11:55:00:\n * var result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))\n * //=> Sun Aug 31 2014 00:00:00\n *\n * @example\n * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:\n * var result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), {weekStartsOn: 1})\n * //=> Mon Sep 01 2014 00:00:00\n */\nfunction startOfWeek (dirtyDate, dirtyOptions) {\n  var weekStartsOn = dirtyOptions ? (Number(dirtyOptions.weekStartsOn) || 0) : 0\n\n  var date = parse(dirtyDate)\n  var day = date.getDay()\n  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn\n\n  date.setDate(date.getDate() - diff)\n  date.setHours(0, 0, 0, 0)\n  return date\n}\n\nmodule.exports = startOfWeek\n","var parse = require('../parse/index.js')\n\n/**\n * @category Year Helpers\n * @summary Return the start of a year for the given date.\n *\n * @description\n * Return the start of a year for the given date.\n * The result will be in the local timezone.\n *\n * @param {Date|String|Number} date - the original date\n * @returns {Date} the start of a year\n *\n * @example\n * // The start of a year for 2 September 2014 11:55:00:\n * var result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))\n * //=> Wed Jan 01 2014 00:00:00\n */\nfunction startOfYear (dirtyDate) {\n  var cleanDate = parse(dirtyDate)\n  var date = new Date(0)\n  date.setFullYear(cleanDate.getFullYear(), 0, 1)\n  date.setHours(0, 0, 0, 0)\n  return date\n}\n\nmodule.exports = startOfYear\n","'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","/*! @preserve\n * numeral.js\n * version : 2.0.6\n * author : Adam Draper\n * license : MIT\n * http://adamwdraper.github.com/Numeral-js/\n */\n\n(function (global, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(factory);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        global.numeral = factory();\n    }\n}(this, function () {\n    /************************************\n        Variables\n    ************************************/\n\n    var numeral,\n        _,\n        VERSION = '2.0.6',\n        formats = {},\n        locales = {},\n        defaults = {\n            currentLocale: 'en',\n            zeroFormat: null,\n            nullFormat: null,\n            defaultFormat: '0,0',\n            scalePercentBy100: true\n        },\n        options = {\n            currentLocale: defaults.currentLocale,\n            zeroFormat: defaults.zeroFormat,\n            nullFormat: defaults.nullFormat,\n            defaultFormat: defaults.defaultFormat,\n            scalePercentBy100: defaults.scalePercentBy100\n        };\n\n\n    /************************************\n        Constructors\n    ************************************/\n\n    // Numeral prototype object\n    function Numeral(input, number) {\n        this._input = input;\n\n        this._value = number;\n    }\n\n    numeral = function(input) {\n        var value,\n            kind,\n            unformatFunction,\n            regexp;\n\n        if (numeral.isNumeral(input)) {\n            value = input.value();\n        } else if (input === 0 || typeof input === 'undefined') {\n            value = 0;\n        } else if (input === null || _.isNaN(input)) {\n            value = null;\n        } else if (typeof input === 'string') {\n            if (options.zeroFormat && input === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {\n                value = null;\n            } else {\n                for (kind in formats) {\n                    regexp = typeof formats[kind].regexps.unformat === 'function' ? formats[kind].regexps.unformat() : formats[kind].regexps.unformat;\n\n                    if (regexp && input.match(regexp)) {\n                        unformatFunction = formats[kind].unformat;\n\n                        break;\n                    }\n                }\n\n                unformatFunction = unformatFunction || numeral._.stringToNumber;\n\n                value = unformatFunction(input);\n            }\n        } else {\n            value = Number(input)|| null;\n        }\n\n        return new Numeral(input, value);\n    };\n\n    // version number\n    numeral.version = VERSION;\n\n    // compare numeral object\n    numeral.isNumeral = function(obj) {\n        return obj instanceof Numeral;\n    };\n\n    // helper functions\n    numeral._ = _ = {\n        // formats numbers separators, decimals places, signs, abbreviations\n        numberToFormat: function(value, format, roundingFunction) {\n            var locale = locales[numeral.options.currentLocale],\n                negP = false,\n                optDec = false,\n                leadingCount = 0,\n                abbr = '',\n                trillion = 1000000000000,\n                billion = 1000000000,\n                million = 1000000,\n                thousand = 1000,\n                decimal = '',\n                neg = false,\n                abbrForce, // force abbreviation\n                abs,\n                min,\n                max,\n                power,\n                int,\n                precision,\n                signed,\n                thousands,\n                output;\n\n            // make sure we never format a null value\n            value = value || 0;\n\n            abs = Math.abs(value);\n\n            // see if we should use parentheses for negative number or if we should prefix with a sign\n            // if both are present we default to parentheses\n            if (numeral._.includes(format, '(')) {\n                negP = true;\n                format = format.replace(/[\\(|\\)]/g, '');\n            } else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {\n                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;\n                format = format.replace(/[\\+|\\-]/g, '');\n            }\n\n            // see if abbreviation is wanted\n            if (numeral._.includes(format, 'a')) {\n                abbrForce = format.match(/a(k|m|b|t)?/);\n\n                abbrForce = abbrForce ? abbrForce[1] : false;\n\n                // check for space before abbreviation\n                if (numeral._.includes(format, ' a')) {\n                    abbr = ' ';\n                }\n\n                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');\n\n                if (abs >= trillion && !abbrForce || abbrForce === 't') {\n                    // trillion\n                    abbr += locale.abbreviations.trillion;\n                    value = value / trillion;\n                } else if (abs < trillion && abs >= billion && !abbrForce || abbrForce === 'b') {\n                    // billion\n                    abbr += locale.abbreviations.billion;\n                    value = value / billion;\n                } else if (abs < billion && abs >= million && !abbrForce || abbrForce === 'm') {\n                    // million\n                    abbr += locale.abbreviations.million;\n                    value = value / million;\n                } else if (abs < million && abs >= thousand && !abbrForce || abbrForce === 'k') {\n                    // thousand\n                    abbr += locale.abbreviations.thousand;\n                    value = value / thousand;\n                }\n            }\n\n            // check for optional decimals\n            if (numeral._.includes(format, '[.]')) {\n                optDec = true;\n                format = format.replace('[.]', '.');\n            }\n\n            // break number and format\n            int = value.toString().split('.')[0];\n            precision = format.split('.')[1];\n            thousands = format.indexOf(',');\n            leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;\n\n            if (precision) {\n                if (numeral._.includes(precision, '[')) {\n                    precision = precision.replace(']', '');\n                    precision = precision.split('[');\n                    decimal = numeral._.toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);\n                } else {\n                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);\n                }\n\n                int = decimal.split('.')[0];\n\n                if (numeral._.includes(decimal, '.')) {\n                    decimal = locale.delimiters.decimal + decimal.split('.')[1];\n                } else {\n                    decimal = '';\n                }\n\n                if (optDec && Number(decimal.slice(1)) === 0) {\n                    decimal = '';\n                }\n            } else {\n                int = numeral._.toFixed(value, 0, roundingFunction);\n            }\n\n            // check abbreviation again after rounding\n            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {\n                int = String(Number(int) / 1000);\n\n                switch (abbr) {\n                    case locale.abbreviations.thousand:\n                        abbr = locale.abbreviations.million;\n                        break;\n                    case locale.abbreviations.million:\n                        abbr = locale.abbreviations.billion;\n                        break;\n                    case locale.abbreviations.billion:\n                        abbr = locale.abbreviations.trillion;\n                        break;\n                }\n            }\n\n\n            // format number\n            if (numeral._.includes(int, '-')) {\n                int = int.slice(1);\n                neg = true;\n            }\n\n            if (int.length < leadingCount) {\n                for (var i = leadingCount - int.length; i > 0; i--) {\n                    int = '0' + int;\n                }\n            }\n\n            if (thousands > -1) {\n                int = int.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + locale.delimiters.thousands);\n            }\n\n            if (format.indexOf('.') === 0) {\n                int = '';\n            }\n\n            output = int + decimal + (abbr ? abbr : '');\n\n            if (negP) {\n                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');\n            } else {\n                if (signed >= 0) {\n                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');\n                } else if (neg) {\n                    output = '-' + output;\n                }\n            }\n\n            return output;\n        },\n        // unformats numbers separators, decimals places, signs, abbreviations\n        stringToNumber: function(string) {\n            var locale = locales[options.currentLocale],\n                stringOriginal = string,\n                abbreviations = {\n                    thousand: 3,\n                    million: 6,\n                    billion: 9,\n                    trillion: 12\n                },\n                abbreviation,\n                value,\n                i,\n                regexp;\n\n            if (options.zeroFormat && string === options.zeroFormat) {\n                value = 0;\n            } else if (options.nullFormat && string === options.nullFormat || !string.replace(/[^0-9]+/g, '').length) {\n                value = null;\n            } else {\n                value = 1;\n\n                if (locale.delimiters.decimal !== '.') {\n                    string = string.replace(/\\./g, '').replace(locale.delimiters.decimal, '.');\n                }\n\n                for (abbreviation in abbreviations) {\n                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\\\)|(\\\\' + locale.currency.symbol + ')?(?:\\\\))?)?$');\n\n                    if (stringOriginal.match(regexp)) {\n                        value *= Math.pow(10, abbreviations[abbreviation]);\n                        break;\n                    }\n                }\n\n                // check for negative number\n                value *= (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;\n\n                // remove non numbers\n                string = string.replace(/[^0-9\\.]+/g, '');\n\n                value *= Number(string);\n            }\n\n            return value;\n        },\n        isNaN: function(value) {\n            return typeof value === 'number' && isNaN(value);\n        },\n        includes: function(string, search) {\n            return string.indexOf(search) !== -1;\n        },\n        insert: function(string, subString, start) {\n            return string.slice(0, start) + subString + string.slice(start);\n        },\n        reduce: function(array, callback /*, initialValue*/) {\n            if (this === null) {\n                throw new TypeError('Array.prototype.reduce called on null or undefined');\n            }\n\n            if (typeof callback !== 'function') {\n                throw new TypeError(callback + ' is not a function');\n            }\n\n            var t = Object(array),\n                len = t.length >>> 0,\n                k = 0,\n                value;\n\n            if (arguments.length === 3) {\n                value = arguments[2];\n            } else {\n                while (k < len && !(k in t)) {\n                    k++;\n                }\n\n                if (k >= len) {\n                    throw new TypeError('Reduce of empty array with no initial value');\n                }\n\n                value = t[k++];\n            }\n            for (; k < len; k++) {\n                if (k in t) {\n                    value = callback(value, t[k], k, t);\n                }\n            }\n            return value;\n        },\n        /**\n         * Computes the multiplier necessary to make x >= 1,\n         * effectively eliminating miscalculations caused by\n         * finite precision.\n         */\n        multiplier: function (x) {\n            var parts = x.toString().split('.');\n\n            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);\n        },\n        /**\n         * Given a variable number of arguments, returns the maximum\n         * multiplier that must be used to normalize an operation involving\n         * all of them.\n         */\n        correctionFactor: function () {\n            var args = Array.prototype.slice.call(arguments);\n\n            return args.reduce(function(accum, next) {\n                var mn = _.multiplier(next);\n                return accum > mn ? accum : mn;\n            }, 1);\n        },\n        /**\n         * Implementation of toFixed() that treats floats more like decimals\n         *\n         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present\n         * problems for accounting- and finance-related software.\n         */\n        toFixed: function(value, maxDecimals, roundingFunction, optionals) {\n            var splitValue = value.toString().split('.'),\n                minDecimals = maxDecimals - (optionals || 0),\n                boundedPrecision,\n                optionalsRegExp,\n                power,\n                output;\n\n            // Use the smallest precision value possible to avoid errors from floating point representation\n            if (splitValue.length === 2) {\n              boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);\n            } else {\n              boundedPrecision = minDecimals;\n            }\n\n            power = Math.pow(10, boundedPrecision);\n\n            // Multiply up by precision, round accurately, then divide and use native toFixed():\n            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);\n\n            if (optionals > maxDecimals - boundedPrecision) {\n                optionalsRegExp = new RegExp('\\\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');\n                output = output.replace(optionalsRegExp, '');\n            }\n\n            return output;\n        }\n    };\n\n    // avaliable options\n    numeral.options = options;\n\n    // avaliable formats\n    numeral.formats = formats;\n\n    // avaliable formats\n    numeral.locales = locales;\n\n    // This function sets the current locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    numeral.locale = function(key) {\n        if (key) {\n            options.currentLocale = key.toLowerCase();\n        }\n\n        return options.currentLocale;\n    };\n\n    // This function provides access to the loaded locale data.  If\n    // no arguments are passed in, it will simply return the current\n    // global locale object.\n    numeral.localeData = function(key) {\n        if (!key) {\n            return locales[options.currentLocale];\n        }\n\n        key = key.toLowerCase();\n\n        if (!locales[key]) {\n            throw new Error('Unknown locale : ' + key);\n        }\n\n        return locales[key];\n    };\n\n    numeral.reset = function() {\n        for (var property in defaults) {\n            options[property] = defaults[property];\n        }\n    };\n\n    numeral.zeroFormat = function(format) {\n        options.zeroFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.nullFormat = function (format) {\n        options.nullFormat = typeof(format) === 'string' ? format : null;\n    };\n\n    numeral.defaultFormat = function(format) {\n        options.defaultFormat = typeof(format) === 'string' ? format : '0.0';\n    };\n\n    numeral.register = function(type, name, format) {\n        name = name.toLowerCase();\n\n        if (this[type + 's'][name]) {\n            throw new TypeError(name + ' ' + type + ' already registered.');\n        }\n\n        this[type + 's'][name] = format;\n\n        return format;\n    };\n\n\n    numeral.validate = function(val, culture) {\n        var _decimalSep,\n            _thousandSep,\n            _currSymbol,\n            _valArray,\n            _abbrObj,\n            _thousandRegEx,\n            localeData,\n            temp;\n\n        //coerce val to string\n        if (typeof val !== 'string') {\n            val += '';\n\n            if (console.warn) {\n                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);\n            }\n        }\n\n        //trim whitespaces from either sides\n        val = val.trim();\n\n        //if val is just digits return true\n        if (!!val.match(/^\\d+$/)) {\n            return true;\n        }\n\n        //if val is empty return false\n        if (val === '') {\n            return false;\n        }\n\n        //get the decimal and thousands separator from numeral.localeData\n        try {\n            //check if the culture is understood by numeral. if not, default it to current locale\n            localeData = numeral.localeData(culture);\n        } catch (e) {\n            localeData = numeral.localeData(numeral.locale());\n        }\n\n        //setup the delimiters and currency symbol based on culture/locale\n        _currSymbol = localeData.currency.symbol;\n        _abbrObj = localeData.abbreviations;\n        _decimalSep = localeData.delimiters.decimal;\n        if (localeData.delimiters.thousands === '.') {\n            _thousandSep = '\\\\.';\n        } else {\n            _thousandSep = localeData.delimiters.thousands;\n        }\n\n        // validating currency symbol\n        temp = val.match(/^[^\\d]+/);\n        if (temp !== null) {\n            val = val.substr(1);\n            if (temp[0] !== _currSymbol) {\n                return false;\n            }\n        }\n\n        //validating abbreviation symbol\n        temp = val.match(/[^\\d]+$/);\n        if (temp !== null) {\n            val = val.slice(0, -1);\n            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {\n                return false;\n            }\n        }\n\n        _thousandRegEx = new RegExp(_thousandSep + '{2}');\n\n        if (!val.match(/[^\\d.,]/g)) {\n            _valArray = val.split(_decimalSep);\n            if (_valArray.length > 2) {\n                return false;\n            } else {\n                if (_valArray.length < 2) {\n                    return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx));\n                } else {\n                    if (_valArray[0].length === 1) {\n                        return ( !! _valArray[0].match(/^\\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n                    } else {\n                        return ( !! _valArray[0].match(/^\\d+.*\\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\\d+$/));\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n\n    /************************************\n        Numeral Prototype\n    ************************************/\n\n    numeral.fn = Numeral.prototype = {\n        clone: function() {\n            return numeral(this);\n        },\n        format: function(inputString, roundingFunction) {\n            var value = this._value,\n                format = inputString || options.defaultFormat,\n                kind,\n                output,\n                formatFunction;\n\n            // make sure we have a roundingFunction\n            roundingFunction = roundingFunction || Math.round;\n\n            // format based on value\n            if (value === 0 && options.zeroFormat !== null) {\n                output = options.zeroFormat;\n            } else if (value === null && options.nullFormat !== null) {\n                output = options.nullFormat;\n            } else {\n                for (kind in formats) {\n                    if (format.match(formats[kind].regexps.format)) {\n                        formatFunction = formats[kind].format;\n\n                        break;\n                    }\n                }\n\n                formatFunction = formatFunction || numeral._.numberToFormat;\n\n                output = formatFunction(value, format, roundingFunction);\n            }\n\n            return output;\n        },\n        value: function() {\n            return this._value;\n        },\n        input: function() {\n            return this._input;\n        },\n        set: function(value) {\n            this._value = Number(value);\n\n            return this;\n        },\n        add: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n\n            function cback(accum, curr, currI, O) {\n                return accum + Math.round(corrFactor * curr);\n            }\n\n            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;\n\n            return this;\n        },\n        subtract: function(value) {\n            var corrFactor = _.correctionFactor.call(null, this._value, value);\n\n            function cback(accum, curr, currI, O) {\n                return accum - Math.round(corrFactor * curr);\n            }\n\n            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;\n\n            return this;\n        },\n        multiply: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) * Math.round(curr * corrFactor) / Math.round(corrFactor * corrFactor);\n            }\n\n            this._value = _.reduce([this._value, value], cback, 1);\n\n            return this;\n        },\n        divide: function(value) {\n            function cback(accum, curr, currI, O) {\n                var corrFactor = _.correctionFactor(accum, curr);\n                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);\n            }\n\n            this._value = _.reduce([this._value, value], cback);\n\n            return this;\n        },\n        difference: function(value) {\n            return Math.abs(numeral(this._value).subtract(value).value());\n        }\n    };\n\n    /************************************\n        Default Locale && Format\n    ************************************/\n\n    numeral.register('locale', 'en', {\n        delimiters: {\n            thousands: ',',\n            decimal: '.'\n        },\n        abbreviations: {\n            thousand: 'k',\n            million: 'm',\n            billion: 'b',\n            trillion: 't'\n        },\n        ordinal: function(number) {\n            var b = number % 10;\n            return (~~(number % 100 / 10) === 1) ? 'th' :\n                (b === 1) ? 'st' :\n                (b === 2) ? 'nd' :\n                (b === 3) ? 'rd' : 'th';\n        },\n        currency: {\n            symbol: '$'\n        }\n    });\n\n    \n\n(function() {\n        numeral.register('format', 'bps', {\n            regexps: {\n                format: /(BPS)/,\n                unformat: /(BPS)/\n            },\n            format: function(value, format, roundingFunction) {\n                var space = numeral._.includes(format, ' BPS') ? ' ' : '',\n                    output;\n\n                value = value * 10000;\n\n                // check for space before BPS\n                format = format.replace(/\\s?BPS/, '');\n\n                output = numeral._.numberToFormat(value, format, roundingFunction);\n\n                if (numeral._.includes(output, ')')) {\n                    output = output.split('');\n\n                    output.splice(-1, 0, space + 'BPS');\n\n                    output = output.join('');\n                } else {\n                    output = output + space + 'BPS';\n                }\n\n                return output;\n            },\n            unformat: function(string) {\n                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);\n            }\n        });\n})();\n\n\n(function() {\n        var decimal = {\n            base: 1000,\n            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n        },\n        binary = {\n            base: 1024,\n            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']\n        };\n\n    var allSuffixes =  decimal.suffixes.concat(binary.suffixes.filter(function (item) {\n            return decimal.suffixes.indexOf(item) < 0;\n        }));\n        var unformatRegex = allSuffixes.join('|');\n        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)\n        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';\n\n    numeral.register('format', 'bytes', {\n        regexps: {\n            format: /([0\\s]i?b)/,\n            unformat: new RegExp(unformatRegex)\n        },\n        format: function(value, format, roundingFunction) {\n            var output,\n                bytes = numeral._.includes(format, 'ib') ? binary : decimal,\n                suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',\n                power,\n                min,\n                max;\n\n            // check for space before\n            format = format.replace(/\\s?i?b/, '');\n\n            for (power = 0; power <= bytes.suffixes.length; power++) {\n                min = Math.pow(bytes.base, power);\n                max = Math.pow(bytes.base, power + 1);\n\n                if (value === null || value === 0 || value >= min && value < max) {\n                    suffix += bytes.suffixes[power];\n\n                    if (min > 0) {\n                        value = value / min;\n                    }\n\n                    break;\n                }\n            }\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            return output + suffix;\n        },\n        unformat: function(string) {\n            var value = numeral._.stringToNumber(string),\n                power,\n                bytesMultiplier;\n\n            if (value) {\n                for (power = decimal.suffixes.length - 1; power >= 0; power--) {\n                    if (numeral._.includes(string, decimal.suffixes[power])) {\n                        bytesMultiplier = Math.pow(decimal.base, power);\n\n                        break;\n                    }\n\n                    if (numeral._.includes(string, binary.suffixes[power])) {\n                        bytesMultiplier = Math.pow(binary.base, power);\n\n                        break;\n                    }\n                }\n\n                value *= (bytesMultiplier || 1);\n            }\n\n            return value;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'currency', {\n        regexps: {\n            format: /(\\$)/\n        },\n        format: function(value, format, roundingFunction) {\n            var locale = numeral.locales[numeral.options.currentLocale],\n                symbols = {\n                    before: format.match(/^([\\+|\\-|\\(|\\s|\\$]*)/)[0],\n                    after: format.match(/([\\+|\\-|\\)|\\s|\\$]*)$/)[0]\n                },\n                output,\n                symbol,\n                i;\n\n            // strip format of spaces and $\n            format = format.replace(/\\s?\\$\\s?/, '');\n\n            // format the number\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            // update the before and after based on value\n            if (value >= 0) {\n                symbols.before = symbols.before.replace(/[\\-\\(]/, '');\n                symbols.after = symbols.after.replace(/[\\-\\)]/, '');\n            } else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {\n                symbols.before = '-' + symbols.before;\n            }\n\n            // loop through each before symbol\n            for (i = 0; i < symbols.before.length; i++) {\n                symbol = symbols.before[i];\n\n                switch (symbol) {\n                    case '$':\n                        output = numeral._.insert(output, locale.currency.symbol, i);\n                        break;\n                    case ' ':\n                        output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);\n                        break;\n                }\n            }\n\n            // loop through each after symbol\n            for (i = symbols.after.length - 1; i >= 0; i--) {\n                symbol = symbols.after[i];\n\n                switch (symbol) {\n                    case '$':\n                        output = i === symbols.after.length - 1 ? output + locale.currency.symbol : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));\n                        break;\n                    case ' ':\n                        output = i === symbols.after.length - 1 ? output + ' ' : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));\n                        break;\n                }\n            }\n\n\n            return output;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'exponential', {\n        regexps: {\n            format: /(e\\+|e-)/,\n            unformat: /(e\\+|e-)/\n        },\n        format: function(value, format, roundingFunction) {\n            var output,\n                exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0',\n                parts = exponential.split('e');\n\n            format = format.replace(/e[\\+|\\-]{1}0/, '');\n\n            output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);\n\n            return output + 'e' + parts[1];\n        },\n        unformat: function(string) {\n            var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'),\n                value = Number(parts[0]),\n                power = Number(parts[1]);\n\n            power = numeral._.includes(string, 'e-') ? power *= -1 : power;\n\n            function cback(accum, curr, currI, O) {\n                var corrFactor = numeral._.correctionFactor(accum, curr),\n                    num = (accum * corrFactor) * (curr * corrFactor) / (corrFactor * corrFactor);\n                return num;\n            }\n\n            return numeral._.reduce([value, Math.pow(10, power)], cback, 1);\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'ordinal', {\n        regexps: {\n            format: /(o)/\n        },\n        format: function(value, format, roundingFunction) {\n            var locale = numeral.locales[numeral.options.currentLocale],\n                output,\n                ordinal = numeral._.includes(format, ' o') ? ' ' : '';\n\n            // check for space before\n            format = format.replace(/\\s?o/, '');\n\n            ordinal += locale.ordinal(value);\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            return output + ordinal;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'percentage', {\n        regexps: {\n            format: /(%)/,\n            unformat: /(%)/\n        },\n        format: function(value, format, roundingFunction) {\n            var space = numeral._.includes(format, ' %') ? ' ' : '',\n                output;\n\n            if (numeral.options.scalePercentBy100) {\n                value = value * 100;\n            }\n\n            // check for space before %\n            format = format.replace(/\\s?\\%/, '');\n\n            output = numeral._.numberToFormat(value, format, roundingFunction);\n\n            if (numeral._.includes(output, ')')) {\n                output = output.split('');\n\n                output.splice(-1, 0, space + '%');\n\n                output = output.join('');\n            } else {\n                output = output + space + '%';\n            }\n\n            return output;\n        },\n        unformat: function(string) {\n            var number = numeral._.stringToNumber(string);\n            if (numeral.options.scalePercentBy100) {\n                return number * 0.01;\n            }\n            return number;\n        }\n    });\n})();\n\n\n(function() {\n        numeral.register('format', 'time', {\n        regexps: {\n            format: /(:)/,\n            unformat: /(:)/\n        },\n        format: function(value, format, roundingFunction) {\n            var hours = Math.floor(value / 60 / 60),\n                minutes = Math.floor((value - (hours * 60 * 60)) / 60),\n                seconds = Math.round(value - (hours * 60 * 60) - (minutes * 60));\n\n            return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);\n        },\n        unformat: function(string) {\n            var timeArray = string.split(':'),\n                seconds = 0;\n\n            // turn hours and minutes into seconds and add them all up\n            if (timeArray.length === 3) {\n                // hours\n                seconds = seconds + (Number(timeArray[0]) * 60 * 60);\n                // minutes\n                seconds = seconds + (Number(timeArray[1]) * 60);\n                // seconds\n                seconds = seconds + Number(timeArray[2]);\n            } else if (timeArray.length === 2) {\n                // minutes\n                seconds = seconds + (Number(timeArray[0]) * 60);\n                // seconds\n                seconds = seconds + Number(timeArray[1]);\n            }\n            return Number(seconds);\n        }\n    });\n})();\n\nreturn numeral;\n}));\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","const expressions = require('angular-expressions')\nrequire('url')\nrequire('./filters') // ensure filters are loaded into (shared) expressions object\nconst OD = require('./fieldtypes')\nconst { AST, astMutateInPlace, escapeQuotes, unEscapeQuotes } = require('./estree')\nexports.AST = AST\nexports.escapeQuotes = escapeQuotes\nexports.unEscapeQuotes = unEscapeQuotes\nexports.serializeAST = AST.serialize // this export is redundant and deprecated, slated for removal in next version\n\nconst parseContentArray = function (contentArray, bIncludeExpressions = true, bIncludeListPunctuation = true) {\n  // contentArray can be either an array of strings (as from a text template split via regex)\n  // or an array of objects with field text and field IDs (as extracted from a DOCX template)\n  // In the latter case (array of objects), sub-arrays indicate discreet blocks of content (paragraphs, table cells, etc.)??\n  const astBody = []\n  let i = 0\n  while (i < contentArray.length) { // we use a 'while' because contentArray gets shorter as we go!\n    let parsedContentItem = parseContentItem(i, contentArray, bIncludeExpressions, bIncludeListPunctuation)\n    if (parsedContentItem.length == 1) {\n      let parsedContent = parsedContentItem[0]\n      if (typeof parsedContent === 'object' &&\n           (parsedContent.type == OD.EndList ||\n            parsedContent.type == OD.EndIf ||\n            parsedContent.type == OD.Else ||\n            parsedContent.type == OD.ElseIf\n           )\n      ) {\n        throw new Error(`Encountered an ${parsedContent.type}${parsedContent.id ? ` (field ${parsedContent.id})` : ''} without a matching ${(parsedContent.type === OD.EndList) ? 'List' : 'If' }`)\n      }\n    }\n    Array.prototype.push.apply(astBody, parsedContentItem)\n    i++\n  }\n  return astBody\n}\nexports.parseContentArray = parseContentArray\n\nconst buildLogicTree = function (astBody) {\n  // return a copy of astBody with all (or at least some) logically insignificant nodes pruned out:\n  // remove plain text nodes (non-dynamic)\n  // remove EndIf and EndList nodes\n  // remove Content nodes that are already defined in the same logical/list scope\n  // always process down all if branches & lists\n  // ~~~strip field ID metadata (for docx templates) since it no longer applies~~~ revised: leave it in so we know more about error location\n  const copy = reduceContentArray(astBody)\n  simplifyContentArray2(copy)\n  simplifyContentArray3(copy)\n  return copy\n}\nexports.buildLogicTree = buildLogicTree\n\n// const reduceAst = function (ast) {\n\n// }\n\n/**\n * The result of calling compileExpr() is an instance of EvaluateExpression.\n * It is a curried function that (when called with a global and, optionally, local data context) will\n * return the result of evaluating the expression against that data context.\n *\n * The function also has a custom property called 'ast' containing the Abstract Syntax Tree for the parsed expression.\n *\n * @callback EvaluateExpression\n * @param {Object} scope - the (global) scope against which to evaluate the expression\n * @param {Object} locals - the local scope against which to evaluate the expression\n * @returns {*} - the value resulting from the evaluation\n *\n * @property {Object} ast\n */\n\n/**\n * compileExpr takes an expression (as a string) and returns a compiled version of that expression.\n *\n * This functionality is largely inherited from the angular-expressions package.  However, there are a couple\n * problems with the ASTs produced by that package; also, yatte extends the angular-expressions idea of 'filters'\n * with a new variation ('list filters'). These problems and enhancements are addressed here through modifying\n * and extending the returned AST.\n *\n * @param {string} expr\n * @returns {EvaluateExpression}\n */\nconst compileExpr = function (expr) {\n  if (!expr) {\n    throw new Error('Cannot compile empty or null expression')\n  }\n  if (expr == '.') expr = 'this'\n  const cache = compileExpr.cache\n  const cacheKey = expr\n  let result = cache ? cache[cacheKey] : undefined\n  if (!result) {\n    try {\n      result = expressions.compile(expr)\n    } catch (e) {\n      throw new SyntaxError(angularExpressionErrorMessage(e, expr))\n    }\n    // check if angular-expressions gave us back a cached copy that has already been fixed up!\n    if (result.ast.body) { // if the AST still has \"body\" property (which we remove below), it has not yet been fixed\n      // strip out the angular 'toWatch' array, etc., from the AST,\n      // since I'm not entirely sure how to do anything useful with that stuff outside of Angular itself\n      result.ast = reduceAstNode(result.ast.body[0].expression)\n      // extend AST with enhanced nodes for filters; change \"this\" to \"$locals\"\n      const modified = fixFilters(result.ast) // | thisTo$locals(result.ast)\n      // normalize the expression\n      const normalizedExpr = AST.serialize(result.ast)\n      // recompile the expression if filter fixes changed its functionality\n      if (modified) {\n        const existingAst = result.ast\n        result = expressions.compile(normalizedExpr)\n        result.ast = existingAst\n      }\n      // save the normalized expression as a property of the compiled expression\n      result.normalized = normalizedExpr\n      // fix problem with Angular AST -- reversal of terms 'consequent' and 'alternate' in conditionals\n      fixConditionalExpressions(result.ast) // (note: it serializes/normalizes the same whether this has been run or not)\n    }\n    // cache the compiled expression under the original string\n    if (cache) {\n      cache[cacheKey] = result\n    }\n    // does it make any sense to also cache the compiled expression under the normalized string?\n    // Maybe not, since you have to compile the expression in order to GET a normalized string...\n  }\n  return result\n}\ncompileExpr.cache = {}\nexpressions.compile.cache = false // disable angular-expressions' own caching of compiled expressions (we cache instead)\nexports.compileExpr = compileExpr\n\nconst angularExpressionErrorMessage = function (e, expr) {\n  const errLines = e.message.split('\\n')\n  if (errLines[0].startsWith('[$parse:syntax]')) {\n    const errUrl = new URL(errLines[1])\n    const token = errUrl.searchParams.get('p0')\n    const msg = errUrl.searchParams.get('p1')\n    const position = errUrl.searchParams.get('p2')\n    const expr = errUrl.searchParams.get('p3')\n    return `Syntax Error: '${token}' ${msg}:\\n${expr}\\n${' '.repeat(position - 1) + '^'.repeat(token.length)}`\n  }\n  if (errLines[0].startsWith('[$parse:lexerr]')) {\n    let msg = errLines[0].substr(15).trim()\n    const errInfo = msg.match(/^(.+) +at columns (\\d+).*?\\[(.*?)\\]/)\n    const expr = msg.match(/in expression \\[(.*)\\].*?$/)[1]\n    msg = errInfo[1].trim()\n    const position = errInfo[2]\n    const token = errInfo[3]\n    return `${msg} '${token}':\\n${expr}\\n${' '.repeat(position) + '^'.repeat(token.length)}`\n  }\n  if (e.message === 'Cannot read property \\'$stateful\\' of undefined') {\n    return 'Syntax Error: did you refer to a non-existant filter?\\n' + expr\n  }\n  return e.message\n}\n\nconst parseContentItem = function (idx, contentArray, bIncludeExpressions = true, bIncludeListPunctuation = true) {\n  let contentItem = contentArray[idx]\n  const parsedItems = []\n  if (Array.isArray(contentItem)) {\n    // if there's a sub-array, that item must be its own valid sequence of fields with appropriately matched ifs/endifs and/or lists/endlists\n    let parsedBlockContent = parseContentArray(contentItem, bIncludeExpressions, bIncludeListPunctuation)\n    Array.prototype.push.apply(parsedItems, parsedBlockContent)\n  } else {\n    const parsedContent = parseField(contentArray, idx, bIncludeExpressions, bIncludeListPunctuation)\n    if (parsedContent !== null) {\n      parsedItems.push(parsedContent)\n    }\n  }\n  return parsedItems\n}\n\nconst parseField = function (contentArray, idx = 0, bIncludeExpressions = true, bIncludeListPunctuation = true) {\n  const contentArrayItem = contentArray[idx]\n  let content, fieldId\n  if (typeof contentArrayItem === 'string') {\n    if (contentArrayItem.length == 0) return null // empty string == ignore (== null)\n    content = getFieldContent(contentArrayItem)\n    if (content === null) return contentArrayItem // not a field means it's static text\n    fieldId = void 0\n  } else {\n    // field object, e.g. extracted from DOCX\n    content = contentArrayItem.content\n    fieldId = contentArrayItem.id\n  }\n\n  if (content === null) { throw new Error(`Unrecognized field text: '${contentArrayItem}'`) }\n\n  // parse the field\n  let match, node\n  if ((match = _ifRE.exec(content)) !== null) {\n    node = createNode(OD.If, match[1], fieldId)\n    if (bIncludeExpressions) parseFieldExpr(node)\n    node.contentArray = parseContentUntilMatch(contentArray, idx + 1, OD.EndIf, fieldId, bIncludeExpressions, bIncludeListPunctuation)\n  } else if ((match = _elseifRE.exec(content)) !== null) {\n    node = createNode(OD.ElseIf, match[1], fieldId)\n    if (bIncludeExpressions) parseFieldExpr(node)\n    node.contentArray = []\n  } else if (_elseRE.test(content)) {\n    node = createNode(OD.Else, void 0, fieldId, [])\n  } else if (_endifRE.test(content)) {\n    node = createNode(OD.EndIf, void 0, fieldId)\n  } else if ((match = _listRE.exec(content)) !== null) {\n    node = createNode(OD.List, match[1], fieldId)\n    if (bIncludeExpressions) {\n      parseFieldExpr(node)\n    }\n    node.contentArray = parseContentUntilMatch(contentArray, idx + 1, OD.EndList, fieldId, bIncludeExpressions, bIncludeListPunctuation)\n  } else if (_endlistRE.test(content)) {\n    node = createNode(OD.EndList, void 0, fieldId)\n  } else {\n    node = createNode(OD.Content, content.trim(), fieldId)\n    if (bIncludeExpressions) parseFieldExpr(node)\n  }\n  return node\n}\n\nconst createNode = function (type, expr, id, contentArray) {\n  const newNode = { type: type }\n  if (typeof expr === 'string') newNode.expr = expr\n  if (typeof id === 'string') newNode.id = id\n  if (Array.isArray(contentArray)) newNode.contentArray = contentArray\n  return newNode\n}\n\nconst parseFieldExpr = function (fieldObj) {\n  // fieldObj is an object with two properties:\n  //   type (string): the field type\n  //   expr (string): the expression within the field that wants to be parsed\n  const expectarray = (fieldObj.type == OD.List)\n  const compiledExpr = compileExpr(fieldObj.expr)\n  fieldObj.exprAst = compiledExpr.ast\n  if (expectarray) {\n    fieldObj.exprAst.expectarray = expectarray\n  }\n  fieldObj.expr = compiledExpr.normalized // normalize all expressions\n  return compiledExpr\n}\n\nconst parseContentUntilMatch = function (contentArray, startIdx, targetType, originId, bIncludeExpressions, bIncludeListPunctuation) {\n  // parses WITHIN THE SAME CONTENT ARRAY (block) until it finds a field of the given targetType\n  // returns a content array \n  let idx = startIdx\n  const result = []\n  let parentContent = result\n  let elseEncountered = false\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const parsedContent = parseContentItem(idx, contentArray, bIncludeExpressions, bIncludeListPunctuation)\n    const isObj = (parsedContent.length == 1 && typeof parsedContent[0] === 'object' && parsedContent[0] !== null)\n    idx++\n    if (isObj && parsedContent[0].type == targetType) {\n      if (parsedContent[0].type == OD.EndList && bIncludeListPunctuation) {\n        // future: possibly inject this only if we're in a list on which the \"punc\" filter was used\n        // (because without the \"punc\" filter specifying list punctuation, this node will be a no-op)\n        // However, that is a little more complicated than it might seem, because this\n        // code operates in parallel with OpenDocx, which does the same thing (always inserting\n        // a punctuation placeholder at the tail-end of every list) for DOCX templates.\n        // See \"puncElem\" in OpenDocx.Templater\\Templater.cs\n        injectListPunctuationNode(parentContent, bIncludeExpressions)\n      }\n      parentContent.push(parsedContent[0])\n      break\n    }\n    if (parsedContent) { parsedContent.forEach(pc => { if (pc) { parentContent.push(pc)} }) }\n    if (isObj && (parsedContent[0].type == OD.ElseIf || parsedContent[0].type == OD.Else)) {\n      if (targetType == OD.EndIf) {\n        if (elseEncountered) { throw new Error(`An ${parsedContent[0].type}${parsedContent[0].id ? ` (field ${parsedContent[0].id})` : ''} cannot follow an Else`) }\n        if (parsedContent[0].type == OD.Else) { elseEncountered = true }\n        parentContent = parsedContent[0].contentArray\n      } else if (targetType == OD.EndList) {\n        throw new Error(`Encountered an ${parsedContent[0].type}${parsedContent[0].id ? ` (field ${parsedContent[0].id})` : ''} when expecting ${originId ? `field ${originId}'s` : 'an'} EndList`)\n      }\n    }\n    if (isObj && (parsedContent[0].type == OD.EndIf || parsedContent[0].type == OD.EndList)) {\n      throw new Error(`Encountered an ${parsedContent[0].type}${parsedContent[0].id ? ` (field ${parsedContent[0].id})` : ''} without a matching ${(parsedContent[0].type === OD.EndList) ? 'List' : 'If' }`)\n    }\n    if (idx >= contentArray.length) { throw new Error(`No ${targetType} found to match ${originId ? `field ${originId}'s` : (targetType === OD.EndList) ? 'a' : 'an'} ${(targetType === OD.EndList) ? 'List' : 'If' }`) }\n  }\n  // remove (consume) all parsed items from the contentArray before returning\n  contentArray.splice(startIdx, idx - startIdx)\n  return result\n}\n\nconst injectListPunctuationNode = function (contentArray, bIncludeExpressions) {\n  // synthesize list punctuation node\n  const puncNode = createNode(OD.Content, '_punc', void 0) // id==undefined because there is not (yet) a corresponding field in the template\n  if (bIncludeExpressions) parseFieldExpr(puncNode)\n  // find last non-empty node in the list\n  let i = contentArray.length - 1\n  while (i >= 0 && (contentArray[i] === '' || contentArray[i] === null)) {\n    i--\n  }\n  const priorNode = (i >= 0) ? contentArray[i] : null\n  // if it's a text node, place the list punctuation node at its end but PRIOR to any line breaks; otherwise just place the list punctuation at the end\n  if (typeof priorNode === 'string') {\n    let ix = priorNode.length - 1\n    let bInsert = false\n    while (ix >= 0 && '\\r\\n'.includes(priorNode[ix])) {\n      bInsert = true\n      ix--\n    }\n    if (bInsert) { // split text node and insert Content node\n      const before = priorNode.slice(0, ix + 1)\n      const after = priorNode.slice(ix + 1)\n      if (before.length > 0) {\n        contentArray[i] = before\n        contentArray.splice(i + 1, 0, puncNode, after)\n      } else {\n        contentArray.splice(i, 1, puncNode, after)\n      }\n    } else {\n      contentArray.push(puncNode)\n    }\n  } else {\n    contentArray.push(puncNode)\n  }\n}\n\nconst _ifRE = /^(?:if\\b|\\?)\\s*(.*)$/\nconst _elseifRE = /^(?:elseif\\b|:\\?)\\s*(.*)$/\nconst _elseRE = /^(?:else|:)$/\nconst _endifRE = /^(?:endif|\\/\\?)(?:.*)$/\nconst _listRE = /^(?:list\\b|#)\\s*(.*)$/\nconst _endlistRE = /^(?:endlist|\\/#)(?:.*)$/\nconst _curlyquotes = /[]/g\nconst _zws = /[\\u{200B}\\u{200C}]/gu\n\nconst getFieldContent = function (text) {\n  if (text.slice(0, 1) == '[' && text.slice(-1) == ']') {\n    return text.slice(1, -1).replace(_curlyquotes, '\"').replace(_zws, '')\n  }\n  return null\n}\n\nconst reduceContentArray = function (astBody, newBody = null, scope = null, parentScope = null) {\n  // prune plain text nodes (non-dynamic, so they don't affect logic)\n  // prune EndIf and EndList nodes (only important insofar as we need to match up nodes to fields -- which will not be the case with a reduced logic tree)\n  // prune redundant Content nodes that are already defined in the same logical & list scope\n  // always process down all if branches & lists\n  //    but mark check whether each if expression is the first (in its scope) to refer to the expression, and if so, indicate it on the node\n  // future: compare logical & list scopes of each item, and eliminate logical branches and list iterations that are redundant\n  if (newBody === null) newBody = []\n  if (scope === null) scope = {}\n  for (const obj of astBody) {\n    const newObj = reduceContentNode(obj, scope, parentScope)\n    if (newObj !== null) {\n      newBody.push(newObj)\n    }\n  }\n  return newBody\n}\n\nconst reduceContentNode = function (astNode, scope, parentScope = null) {\n  if (typeof astNode === 'string') return null // plain text node -- boilerplate content in a text template (does not occur in other template types)\n  if (astNode.type == OD.EndList || astNode.type == OD.EndIf) return null\n\n  if (astNode.type == OD.Content) {\n    if (scope[astNode.expr]) return null // expression already defined in this scope\n    //eslint-disable-next-line no-unused-vars\n    const { id, ...copyOfNode } = astNode // strip field id if it's there // TODO: stop stripping the id!\n    scope[astNode.expr] = copyOfNode\n    return copyOfNode\n  }\n  if (astNode.type == OD.List) {\n    let existingListNode\n    //eslint-disable-next-line no-cond-assign\n    if (existingListNode = scope[astNode.expr]) { // this list has already been added to the parent scope; revisit it to add more content members if necessary\n      reduceContentArray(astNode.contentArray, existingListNode.contentArray, existingListNode.scope)\n      return null\n    } else {\n      //eslint-disable-next-line no-unused-vars\n      const { id, contentArray, ...copyOfNode } = astNode // TODO: stop stripping the id!\n      copyOfNode.scope = {} // fresh new wholly separate scope for lists\n      copyOfNode.contentArray = reduceContentArray(contentArray, null, copyOfNode.scope)\n      scope[astNode.expr] = copyOfNode // set BEFORE recursion for consistent results?  (or is it intentionally after?)\n      return copyOfNode\n    }\n  }\n  if (astNode.type == OD.If || astNode.type == OD.ElseIf || astNode.type == OD.Else) {\n    // if's are always left in at this point (because of their importance to the logic;\n    // a lot more work would be required to accurately optimize them out.)\n    // HOWEVER, we can't add the expr to the parent scope by virtue of it having been referenced in a condition,\n    // because it means something different for the same expression to be evaluated in a Content node vs. an If/ElseIf node,\n    // and therefore an expression emitted/evaluated as part of a condition still needs to be emitted/evaluated as part of a merge/content node.\n    // AND VICE VERSA: an expression emitted as part of a content node STILL needs to be emitted as part of a condition, too.\n\n    //eslint-disable-next-line no-unused-vars\n    const { id, contentArray, ...copyOfNode } = astNode // TODO: stop stripping the id!\n    // this 'parentScope' thing is a bit tricky.  The parentScope argument is only supplied when we're inside an If/ElseIf/Else block within the current scope.\n    // If supplied, it INDIRECTLY refers to the actual scope -- basically, successive layers of \"if\" blocks\n    // that each establish a new \"mini\" scope, that has the parent scope as its prototype.\n    // This means, a reference to an identifier in a parent scope, will prevent that identifier from appearing (redundantly) in a child;\n    // but a reference to an identifier in a child scope, will NOT prevent that identifier from appearing in a parent scope.\n    const pscope = (parentScope != null) ? parentScope : scope\n    if (copyOfNode.type == OD.If || copyOfNode.type == OD.ElseIf) {\n      if (!(('if$' + astNode.expr) in pscope)) {\n        pscope['if$' + astNode.expr] = copyOfNode\n      }\n    }\n    const childContext = Object.create(pscope)\n    copyOfNode.contentArray = reduceContentArray(contentArray, null, childContext, pscope)\n    return copyOfNode\n  }\n}\n\nconst simplifyContentArray2 = function (astBody) {\n  // 2nd pass at simplifying logic\n  // for now, just clean up scope helpers leftover from first pass\n  for (const obj of astBody) {\n    simplifyNode2(obj)\n  }\n}\n\nconst simplifyNode2 = function (astNode) {\n  if (astNode.scope) { delete astNode.scope }\n  if (Array.isArray(astNode.contentArray)) { simplifyContentArray2(astNode.contentArray) }\n}\n\nconst simplifyContentArray3 = function (body, scope = {}) {\n  // 3rd pass at simplifying scopes\n  let initialScope = { ...scope } // shallow-clone the scope to start with\n  // first go through content fields\n  let i = 0\n  while (i < body.length) {\n    const field = body[i]\n    let nodeRemoved = false\n    if (field.type === OD.Content) {\n      if (field.expr in scope) {\n        body.splice(i, 1)\n        nodeRemoved = true\n      } else {\n        scope[field.expr] = true\n      }\n    }\n    if (!nodeRemoved) {\n      i++\n    }\n  }\n  // then recurse into ifs and lists\n  for (const field of body) {\n    if (field.type === OD.List) {\n      if (!(field.expr in scope)) {\n        scope[field.expr] = true\n      }\n      simplifyContentArray3(field.contentArray, {}) // new scope for lists\n    } else if (field.type === OD.If) {\n      // the content in an if block has everything in its parent scope\n      simplifyContentArray3(field.contentArray, { ...scope }) // copy the parent scope\n    } else if (field.type === OD.ElseIf || field.type === OD.Else) {\n      // elseif and else fields are (in the logic tree) children of ifs, but they do NOT have access to the parent scope, reset to initial scope for if\n      simplifyContentArray3(field.contentArray, { ...initialScope })\n    }\n  }\n  // note: although this will eliminate some redundant fields, it will not eliminate all of them.\n  // A partial rewrite is planned to implement a new, more straight-forward approach.\n}\n\nconst reduceAstNode = function (astNode) {\n  // prune endlessly recursive property\n  //eslint-disable-next-line no-unused-vars\n  const { toWatch, watchId, ...simplified } = astNode\n  for (const prop in simplified) {\n    switch (prop) {\n      case 'object':\n      case 'property':\n      case 'callee':\n      case 'key':\n      case 'valule':\n      case 'left':\n      case 'right':\n      case 'argument':\n      case 'test':\n      case 'consequent':\n      case 'alternate':\n        // recurse into nodes that can contain expressions of their own\n        simplified[prop] = reduceAstNode(simplified[prop])\n        break\n      case 'arguments':\n      case 'elements':\n      case 'properties': {\n        // recurse into nodes containing arrays of items that can contain expressions\n        const thisArray = simplified[prop]\n        if (thisArray && thisArray.length > 0) {\n          for (let i = 0; i < thisArray.length; i++) {\n            thisArray[i] = reduceAstNode(thisArray[i])\n          }\n        }}\n        break\n      default:\n                // should not need to do anything else\n    }\n  }\n  return simplified\n}\n\n/**\n * Recursively processes the given AST node to determine if it contains any conditional expressions, and if it does,\n * it reverses the \"alternate\" and \"consequent\" properties to conform to the generally-understood meanings of those terms,\n * for consistency and compatibility with other AST node types (IfStatements in particular).\n * See:\n *      https://github.com/estree/estree/blob/master/es5.md#conditionalexpression\n *          ... which does not say what is what, but gives the wrong idea by its ordering of the properties, and\n *      https://github.com/estree/estree/blob/master/es5.md#ifstatement\n *          ... which makes it clear that \"consequent\" is the \"then\", while \"alternate\" is the \"else\" (by virtue of it being optional)\n\n * and all kinds of sources that make the intended meanings of \"consequent\" clear:\n *      https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Conditionals.html\n *      https://en.wikipedia.org/wiki/Conditional_(computer_programming)\n *\n * When Angular parses conditional expressions, although it generally follows a subset of the ESTree spec,\n * it places the portion following '?' in \"alternate\" and the portion following ':' in \"consequent\",\n * which is backwards and causes problems if you intend to use the AST for any other purpose.\n *\n * Note: if this function makes changes, it modifies the given ast *in place*. The return value indicates whether\n *       or not changes were made.\n *\n * @param {object} astNode\n * @returns {boolean}\n */\nconst fixConditionalExpressions = function (astNode) {\n  return astMutateInPlace(astNode, node => {\n    if (node.type === AST.ConditionalExpression) {\n      if (!node.fixed) {\n        const swap = node.alternate\n        node.alternate = node.consequent\n        node.consequent = swap\n        node.fixed = true\n        return true // made a change\n      }\n    }\n    return false // nothing changed\n  })\n}\n\n/**\n * Recursively processes the given AST node to determine if it contains any \"filters\", either typical angular-type filters\n * or yatte list filters. If it does, it modifies the AST to more explicitly and naturally represent these filters.\n *\n * Note: if this function makes changes, it modifies the given ast *in place*. The return value indicates whether\n *       or not changes were made.\n *\n * @param {object} astNode\n * @returns {boolean} true means the AST was modified in such a way as to materially change how the expression should be evaluated;\n * false means the AST may or may not have been modified, but it should not require re-compilation by angular-expressions.\n */\nconst fixFilters = function (astNode) {\n  return astMutateInPlace(astNode, node => {\n    if (node.type === AST.CallExpression && node.filter) {\n      const modified = convertCallNodeToFilterNode(node)\n      if (modified && node.rtl) {\n        const newNode = getRTLFilterChain(node)\n        if (newNode !== node) {\n          node.input = newNode.input\n          node.filter = newNode.filter\n          node.arguments = newNode.arguments\n        }\n      }\n      return modified\n    }\n    return false\n  })\n}\n\n/**\n * Given a chain of one or more filter nodes that are supposed to have right-to-left associativity, but\n * which have been initially parsed (as all filter nodes are by angular-expressions) as left-to-right,\n * reverse the order/structure of the nodes in the chain, and return the node at the beginning of the chain.\n */\nconst getRTLFilterChain = function (node, innerNode = undefined) {\n  // check if its input is also a filter, and if so, recurse / transform AST to reflect correct associativity\n  const inputNode = node.input\n  if (inputNode.type === AST.CallExpression && inputNode.filter) {\n    convertCallNodeToFilterNode(inputNode)\n    if (inputNode.rtl) {\n      const newInnerNode = {\n        type: AST.ListFilterExpression,\n        rtl: true,\n        input: inputNode.arguments[0],\n        filter: node.filter,\n        arguments: innerNode ? [innerNode] : node.arguments,\n        constant: inputNode.arguments[0].constant && (innerNode ? innerNode.constant : node.arguments[0].constant)\n      }\n      return getRTLFilterChain(inputNode, newInnerNode)\n    }\n  }\n  // else\n  if (innerNode) {\n    node.arguments = [innerNode]\n  }\n  return node\n}\n\nconst convertCallNodeToFilterNode = function (node) {\n  node.filter = node.callee\n  delete node.callee\n  node.input = node.arguments.shift()\n  if (['sort', 'filter', 'map', 'some', 'any', 'every', 'all', 'find', 'group'].includes(node.filter.name)) {\n    node.type = AST.ListFilterExpression\n    // resolve aliases\n    if (node.filter.name === 'some') { // alias for 'any'\n      node.filter.name = 'any'\n    } else if (node.filter.name === 'all') { // alias for 'every'\n      node.filter.name = 'every'\n    }\n    node.rtl = ['any', 'every'].includes(node.filter.name)\n    if (isNormalizedListFilterNode(node)) {\n      // the node is a list filter that had formerly been normalized -- re-parse the string argument into the original AST\n      node.arguments.shift() // discard AST's extra \"this\" (added during normalization, when the param expression was stringified)\n      const parsedArg = compileExpr(unEscapeQuotes(node.arguments[0].value))\n      node.arguments[0] = parsedArg.ast\n      return false // existing compiled behavior was already based on the normalized form, so return false to avoid recompilation (which would only be redundant)\n    } else {\n      // the node is a list filter that is just now being parsed & fixed up\n      return true // returning true means after we're done mutating the AST, we'll re-serialize to get the normalized form, and then recompile THAT with angular-expressions\n    }\n  } else {\n    node.type = AST.AngularFilterExpression\n    return false\n  }\n}\n\n/**\n * Recursively processes the given AST node to convert any and all nodes representing the \"this\" token, to the \"$locals\" token instead\n *\n * Note: if this function makes changes, it modifies the given ast *in place*. The return value indicates whether\n *       or not changes were made.\n *\n * @param {object} astNode\n * @returns {boolean} whether or not the AST was modified\n */\nconst thisTo$locals = function (astNode) {\n  return astMutateInPlace(astNode, node => {\n    if (isNormalizedListFilterNode(node)) {\n      // the one case where we LEAVE a ThisExpression in place, is when it's the first (implicit) argument to a ListFilterExpression that has already been fixed up\n      node.arguments[0].preserve = true\n      return false\n    }\n    if (node.type === AST.ThisExpression && !node.preserve) {\n      node.type = AST.LocalsExpression\n      return true\n    }\n    return false\n  })\n}\n\nfunction isNormalizedListFilterNode(node) {\n  if (!node || node.type !== AST.ListFilterExpression) return false\n  let args = node.arguments\n  if (args.length > 1\n    && args[0].type === AST.ThisExpression\n    && args[1].type === AST.Literal)\n  {\n    if (args.length !== 2 && node.filter.name !== 'sort') {\n      console.log(`Warning: ListFilterExpression with multiple arguments: ${AST.serialize(node)}`)\n    }\n    return true\n  }\n  return false\n}\n","// These node types are a subset of those defined in the ESTree specification.\n// For the meaning and specific properties of each type of node, see\n// https://github.com/estree/estree/blob/master/es5.md\n\nconst AST = {\n  Identifier: 'Identifier',\n  Literal: 'Literal',\n  Program: 'Program',\n  ExpressionStatement: 'ExpressionStatement',\n  BlockStatement: 'BlockStatement',\n  EmptyStatement: 'EmptyStatement',\n  IfStatement: 'IfStatement',\n  ForOfStatement: 'ForOfStatement',\n  ThisExpression: 'ThisExpression',\n  ArrayExpression: 'ArrayExpression',\n  ObjectExpression: 'ObjectExpression',\n  Property: 'Property',\n  UnaryExpression: 'UnaryExpression',\n  BinaryExpression: 'BinaryExpression',\n  LogicalExpression: 'LogicalExpression',\n  MemberExpression: 'MemberExpression',\n  ConditionalExpression: 'ConditionalExpression',\n  CallExpression: 'CallExpression',\n  // also includes some custom/proprietary node types:\n  LocalsExpression: 'LocalsExpression', // from angular-expressions -- like 'ThisExpression', but for the local scope (Angular equates \"this\" to the broader evaluation \"scope\")\n  AngularFilterExpression: 'AngularFilterExpression', // properties: input (node), filter (ident), arguments (node array)\n  ListFilterExpression: 'ListFilterExpression', // properties: input (node), filter (ident), arguments (node array), rtl (bool)\n  // also includes a utility method:\n  serialize: serializeAstNode\n}\nexports.AST = AST\n\n// Some serialization logic adapted from AString\n// https://github.com/davidbonnet/astring/blob/master/src/astring.js\n\nconst OPERATOR_PRECEDENCE = {\n  '||': 3,\n  '&&': 4,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  '+': 11,\n  '-': 11,\n  '*': 12,\n  '%': 12,\n  '/': 12\n}\n\n// Enables parenthesis regardless of precedence\nconst NEEDS_PARENTHESES = 17\n\nconst EXPRESSIONS_PRECEDENCE = {\n  // Definitions\n  [AST.ArrayExpression]: 20,\n  [AST.ThisExpression]: 20,\n  [AST.LocalsExpression]: 20,\n  [AST.Identifier]: 20,\n  [AST.Literal]: 18,\n  // Operations\n  [AST.MemberExpression]: 19,\n  [AST.CallExpression]: 19,\n  // Other definitions\n  [AST.ObjectExpression]: NEEDS_PARENTHESES,\n  // Other operations\n  [AST.UnaryExpression]: 15,\n  [AST.BinaryExpression]: 14,\n  [AST.LogicalExpression]: 13,\n  [AST.ConditionalExpression]: 4,\n  [AST.AngularFilterExpression]: 1,\n  [AST.ListFilterExpression]: 1\n}\n\nexports.astMutateInPlace = astMutateInPlace\nfunction astMutateInPlace (node, mutator) {\n  var nodeModified = mutator(node)\n  switch (node.type) {\n    case AST.Program:\n      return nodeModified | node.body.reduce((accumulator, statementObj) => accumulator |= astMutateInPlace(statementObj, mutator), false)\n    case AST.ExpressionStatement:\n      return nodeModified | astMutateInPlace(node.expression, mutator)\n    case AST.Literal:\n    case AST.Identifier:\n    case AST.ThisExpression:\n    case AST.LocalsExpression:\n      return nodeModified\n    case AST.MemberExpression:\n      return nodeModified | astMutateInPlace(node.object, mutator) | astMutateInPlace(node.property, mutator)\n    case AST.CallExpression:\n      return nodeModified | astMutateInPlace(node.callee, mutator) | node.arguments.reduce((accumulator, argObj) => accumulator |= astMutateInPlace(argObj, mutator), false)\n    case AST.AngularFilterExpression:\n    case AST.ListFilterExpression:\n      return nodeModified | astMutateInPlace(node.filter, mutator) | astMutateInPlace(node.input, mutator) | node.arguments.reduce((accumulator, argObj) => accumulator |= astMutateInPlace(argObj, mutator), false)\n    case AST.ArrayExpression:\n      return nodeModified | node.elements.reduce((accumulator, elem) => accumulator |= astMutateInPlace(elem, mutator), false)\n    case AST.ObjectExpression:\n      return nodeModified | node.properties.reduce((accumulator, prop) => accumulator |= astMutateInPlace(prop, mutator), false)\n    case AST.Property:\n      return nodeModified | astMutateInPlace(node.key, mutator) | astMutateInPlace(node.value, mutator)\n    case AST.BinaryExpression:\n    case AST.LogicalExpression:\n      return nodeModified | astMutateInPlace(node.left, mutator) | astMutateInPlace(node.right, mutator)\n    case AST.UnaryExpression:\n      return nodeModified | astMutateInPlace(node.argument, mutator)\n    case AST.ConditionalExpression:\n      return nodeModified | astMutateInPlace(node.test, mutator) | astMutateInPlace(node.consequent, mutator) | astMutateInPlace(node.alternate, mutator)\n    default:\n      return false\n  }\n}\n\nfunction getExpressionPrecedence (node) {\n  if (node.type === AST.CallExpression && node.filter) {\n    return EXPRESSIONS_PRECEDENCE[AST.AngularFilterExpression]\n  } // else\n  return EXPRESSIONS_PRECEDENCE[node.type]\n}\n\nfunction expressionNeedsParentheses (node, parentNode, isRightHand) {\n  const nodePrecedence = getExpressionPrecedence(node)\n  if (nodePrecedence === NEEDS_PARENTHESES) {\n    return true\n  }\n  const parentNodePrecedence = getExpressionPrecedence(parentNode)\n  if (nodePrecedence !== parentNodePrecedence) {\n    // Different node types\n    return nodePrecedence < parentNodePrecedence\n  }\n  if (nodePrecedence !== 13 && nodePrecedence !== 14) {\n    // Not a `LogicalExpression` or `BinaryExpression`\n    return false\n  }\n  if (isRightHand) {\n    // Parenthesis are used if both operators have the same precedence\n    return (OPERATOR_PRECEDENCE[node.operator] <= OPERATOR_PRECEDENCE[parentNode.operator])\n  }\n  return (OPERATOR_PRECEDENCE[node.operator] < OPERATOR_PRECEDENCE[parentNode.operator])\n}\n\nfunction serializeOptionallyWrapped (node, maxPrecedence, orEqual = false) {\n  const wrap = orEqual ? (getExpressionPrecedence(node) <= maxPrecedence) : (getExpressionPrecedence(node) < maxPrecedence)\n  return wrap ? ('(' + serializeAstNode(node) + ')') : serializeAstNode(node)\n}\n\nfunction serializeBinaryExpressionPart (node, parentNode, isRightHand) {\n  /*\n    serializes a left-hand or right-hand expression `node`\n    from a binary expression applying the provided `operator`.\n    The `isRightHand` parameter should be `true` if the `node` is a right-hand argument.\n    */\n  if (expressionNeedsParentheses(node, parentNode, isRightHand)) {\n    return '(' + serializeAstNode(node) + ')'\n  } else {\n    return serializeAstNode(node)\n  }\n}\n\nfunction serializeAstNode (astNode) {\n  switch (astNode.type) {\n    case AST.Program:\n      return astNode.body.map(statement => serializeAstNode(statement)).join('\\n')\n    case AST.ExpressionStatement:\n      return serializeAstNode(astNode.expression)\n    case AST.Literal:\n      if (typeof astNode.value === 'string') { return '\"' + astNode.value + '\"' }\n      if (astNode.value === null) { return 'null' }\n      return astNode.value.toString()\n    case AST.Identifier:\n      return astNode.name\n    case AST.MemberExpression:\n      return serializeOptionallyWrapped(astNode.object, EXPRESSIONS_PRECEDENCE.MemberExpression) +\n                (astNode.computed ? ('[' + serializeAstNode(astNode.property) + ']') : ('.' + serializeAstNode(astNode.property)))\n    case AST.CallExpression: {\n      let str\n      if (astNode.filter) {\n        str = serializeOptionallyWrapped(astNode.arguments[0], EXPRESSIONS_PRECEDENCE[AST.AngularFilterExpression], true) +\n                        '|' + serializeAstNode(astNode.callee)\n        for (let i = 1; i < astNode.arguments.length; i++) {\n          str += ':' + serializeOptionallyWrapped(astNode.arguments[i], EXPRESSIONS_PRECEDENCE[AST.AngularFilterExpression], true)\n        }\n      } else {\n        str = serializeAstNode(astNode.callee) + '(' + astNode.arguments.map(argObj => serializeAstNode(argObj)).join(',') + ')'\n      }\n      return str\n    }\n    case AST.AngularFilterExpression:\n      return serializeOptionallyWrapped(astNode.input, EXPRESSIONS_PRECEDENCE.AngularFilterExpression) + '|' + serializeAstNode(astNode.filter) +\n                astNode.arguments.map(arg => ':' + serializeOptionallyWrapped(arg, EXPRESSIONS_PRECEDENCE.AngularFilterExpression)).join('')\n    case AST.ListFilterExpression:\n      return serializeOptionallyWrapped(astNode.input, EXPRESSIONS_PRECEDENCE.ListFilterExpression, astNode.rtl) +\n                '|' + serializeAstNode(astNode.filter) + ':this' +\n                astNode.arguments.map(arg => `:\"${escapeQuotes(serializeAstNode(arg))}\"`).join('')\n    case AST.ArrayExpression:\n      return '[' + astNode.elements.map(elem => serializeAstNode(elem)).join(',') + ']'\n    case AST.ObjectExpression:\n      return '{' + astNode.properties.map(prop => serializeAstNode(prop)).join(',') + '}'\n    case AST.Property:\n      return (astNode.computed ? '[' : '') + serializeAstNode(astNode.key) + (astNode.computed ? ']' : '') + ':' + serializeAstNode(astNode.value)\n    case AST.BinaryExpression:\n    case AST.LogicalExpression:\n      return serializeBinaryExpressionPart(astNode.left, astNode, false) + astNode.operator + serializeBinaryExpressionPart(astNode.right, astNode, true)\n    case AST.UnaryExpression:\n      return astNode.prefix\n        ? astNode.operator + serializeOptionallyWrapped(astNode.argument, EXPRESSIONS_PRECEDENCE.UnaryExpression)\n        : serializeAstNode(astNode.argument) + astNode.operator\n    case AST.ConditionalExpression:\n      // angular expression parsing has alternate and consequent reversed from their standard meanings!\n      // so serialize according to whether it's been fixed or not\n      return serializeOptionallyWrapped(astNode.test, EXPRESSIONS_PRECEDENCE.ConditionalExpression, true) +\n                    '?' + serializeOptionallyWrapped(astNode.fixed ? astNode.consequent : astNode.alternate, EXPRESSIONS_PRECEDENCE.ConditionalExpression) +\n                    ':' + serializeAstNode(astNode.fixed ? astNode.alternate : astNode.consequent)\n    case AST.ThisExpression:\n      return 'this'\n    case AST.LocalsExpression:\n      return '$locals'\n    default:\n      throw new Error(`Unsupported expression type '${astNode.type}'`)\n  }\n}\n\nexports.escapeQuotes = escapeQuotes\nfunction escapeQuotes (str) {\n  return str.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&apos;') // include ampersands so escaping is nestable AND reversable when nested\n}\n\nexports.unEscapeQuotes = unEscapeQuotes\nfunction unEscapeQuotes (str) {\n  return str.replace(/&apos;/g, '\\'').replace(/&quot;/g, '\"').replace(/&amp;/g, '&')\n}\n","'use strict'\n\nclass EvaluationResult {\n  constructor (value, missing = [], errors = []) {\n    this.value = value\n    this.missing = missing\n    this.errors = errors\n  }\n\n  valueOf () {\n    return ((typeof this.value === 'object') && (this.value !== null)) ? this.value.valueOf() : this.value\n  }\n\n  toString () {\n    return (typeof this.value === 'string')\n      ? this.value\n      : isDef(this.value)\n        ? this.value.toString()\n        : '(missing)'\n  }\n}\nmodule.exports = EvaluationResult\n\nconst isDef = val => val !== null && typeof val !== 'undefined'","// fieldtypes.js\nconst FT = {\n  Content: 'Content',\n  If: 'If',\n  ElseIf: 'ElseIf',\n  Else: 'Else',\n  EndIf: 'EndIf',\n  List: 'List',\n  EndList: 'EndList'\n}\nmodule.exports = FT\n","const expressions = require('angular-expressions')\nconst format = require('date-fns/format')\nconst numeral = require('numeral')\nconst numWords = require('number-to-words')\nconst Scope = require('./scope')\nconst { unEscapeQuotes } = require('./estree')\nconst deepEqual = require('fast-deep-equal')\n\n// define built-in filters\nexpressions.filters.upper = function (input) {\n  if (!input) return input\n  if (typeof input !== 'string') input = input.toString()\n  return input.toUpperCase()\n}\nexpressions.filters.lower = function (input) {\n  if (!input) return input\n  if (typeof input !== 'string') input = input.toString()\n  return input.toLowerCase()\n}\nexpressions.filters.initcap = function (input, forceLower = false) {\n  if (!input) return input\n  if (typeof input !== 'string') input = input.toString()\n  if (forceLower) input = input.toLowerCase()\n  return input.charAt(0).toUpperCase() + input.slice(1)\n}\nexpressions.filters.titlecaps = function (input, forceLower = false) {\n  if (!input) return input\n  if (typeof input !== 'string') input = input.toString()\n  if (forceLower) input = input.toLowerCase()\n  return input.replace(/(^| )(\\w)/g, s => s.toUpperCase())\n}\nexpressions.filters.format = function (input, generalFmt, negativeFmt, zeroFmt) {\n  if (input === null || typeof input === 'undefined') return input\n  if (input instanceof Date) {\n    return format(input, generalFmt)\n  }\n  if (typeof input === 'boolean' || input instanceof Boolean) {\n    input = input.valueOf()\n    if (generalFmt || negativeFmt) {\n      generalFmt = generalFmt ? String(generalFmt) : ''\n      negativeFmt = negativeFmt ? String(negativeFmt) : ''\n      return input ? generalFmt : negativeFmt\n    } // else\n    return input ? 'true' : 'false'\n  }\n  // else number\n  const num = Number(input)\n  let fmtStr\n  if (num == 0) {\n    fmtStr = zeroFmt || generalFmt || '0,0'\n  } else if (num < 0) {\n    fmtStr = negativeFmt || generalFmt || '0,0'\n  } else {\n    fmtStr = generalFmt || '0,0'\n  }\n  if (fmtStr === 'cardinal') {\n    return numWords.toWords(num)\n  }\n  if (fmtStr === 'ordinal') {\n    return numWords.toWordsOrdinal(num)\n  }\n  return numeral(num).format(fmtStr)\n}\nexpressions.filters.cardinal = function (input) {\n  if (input === null || typeof input === 'undefined') return input\n  return numWords.toWords(Number(input))\n}\nexpressions.filters.ordinal = function (input) {\n  if (input === null || typeof input === 'undefined') return input\n  return numWords.toWordsOrdinal(Number(input))\n}\nexpressions.filters.ordsuffix = function (input) {\n  if (input === null || typeof input === 'undefined') return input\n  if (typeof input !== 'number') input = Number(input)\n  switch (input % 10) {\n    case 1: return 'st'\n    case 2: return 'nd'\n    case 3: return 'rd'\n    default: return 'th'\n  }\n}\nexpressions.filters.else = function (input, unansweredFmt) {\n  if (input === null || typeof input === 'undefined') return unansweredFmt\n  return input\n}\n\nexpressions.filters.contains = function (input, value) {\n  if (input === null || typeof input === 'undefined' || input === '') return false\n  if (!Scope.isIterable(input)) return false\n  if (typeof input === 'string') {\n    return input.includes(value.toString())\n  }\n  value = value && value.valueOf()\n  for (const item of input) {\n    if (deepEqual(item && item.valueOf(), value)) {\n      return true\n    }\n  }\n  return false\n}\n\nexpressions.filters.punc = function (inputList, example = '1, 2 and 3') {\n  if (!inputList || !Array.isArray(inputList) || !inputList.length) return inputList\n  const p1 = example.indexOf('1')\n  const p2 = example.indexOf('2')\n  const p3 = example.indexOf('3')\n  if (p1 >= 0 && p2 > p1) {\n    // inputList may be the actual source array (the context stack has not yet been pushed!)\n    // so make a shallow copy before adding any custom properties onto the array\n    inputList = [...inputList]\n    const between = example.slice(p1 + 1, p2)\n    if (p3 > p2) {\n      const last2 = example.slice(p2 + 1, p3)\n      let only2\n      if (last2 !== between && last2.startsWith(between)) // as with an oxford comma: \"1, 2, and 3\"\n      { only2 = last2.slice(between.trimRight().length) } else { only2 = last2 }\n      const suffix = example.slice(p3 + 1)\n      inputList['punc'] = { between, last2, only2, suffix }\n    } else if (p3 < 0) {\n      const suffix = example.slice(p2 + 1)\n      inputList['punc'] = { between, last2: between, only2: between, suffix }\n    }\n  }\n  return inputList\n}\n\n// runtime implementation of list filters:\n\nexpressions.filters.sort = function (input, scope) {\n  if (!input || !Array.isArray(input) || !input.length || arguments.length < 3) return input\n  if (!scope) scope = {}\n  const sortBy = []\n  let i = 2\n  while (i < arguments.length) {\n    const argument = unEscapeQuotes(arguments[i++])\n    sortBy.push({\n      descending: argument[0] === '-',\n      evaluator: expressions.compile('+-'.includes(argument[0]) ? argument.substr(1) : argument)\n    })\n  }\n  function compare (a, b, depth) {\n    if (!depth) {\n      depth = 0\n    }\n    if (depth >= sortBy.length) { return 0 }\n    const valA = sortBy[depth].evaluator(a) // sort expressions must only  refer to stuff in the current list item\n    const valB = sortBy[depth].evaluator(b)\n    if (valA < valB) { return sortBy[depth].descending ? 1 : -1 }\n    if (valA > valB) { return sortBy[depth].descending ? -1 : 1 }\n    return compare(a, b, depth + 1)\n  }\n  return input.slice().sort(compare)\n}\nexpressions.filters.filter = function (input, scope, predicateStr) {\n  return callArrayFunc(Array.prototype.filter, input, scope, predicateStr)\n}\nexpressions.filters.find = function (input, scope, predicateStr) {\n  return callArrayFunc(Array.prototype.find, input, scope, predicateStr)\n}\nexpressions.filters.any = function (input, scope, predicateStr) {\n  return callArrayFunc(Array.prototype.some, input, scope, predicateStr)\n}\nexpressions.filters.some = expressions.filters.any // alias\nexpressions.filters.every = function (input, scope, predicateStr) {\n  return callArrayFunc(Array.prototype.every, input, scope, predicateStr)\n}\nexpressions.filters.all = expressions.filters.every // alias\nexpressions.filters.map = function (input, scope, mappedStr) {\n  return callArrayFunc(Array.prototype.map, input, scope, mappedStr)\n}\nexpressions.filters.group = function (input, scope, groupStr) {\n  if (!input || !Array.isArray(input) || !input.length || arguments.length < 2) {\n    return input\n  }\n  if (!scope) {\n    scope = {}\n  }\n  const evaluator = expressions.compile(unEscapeQuotes(groupStr))\n  return input.reduce(\n    (result, item) => {\n      const key = ['string', 'number'].includes(typeof item) ? evaluator(item) : evaluator(scope, item)\n      let bucket = result.find(b => b._key === key)\n      if (!bucket) {\n        bucket = { _key: key, _values: [] }\n        result.push(bucket)\n      }\n      bucket._values.push(item)\n      return result\n    },\n    []\n  )\n}\n\nfunction callArrayFunc (func, array, scope, predicateStr) {\n  if (!array || !Array.isArray(array) || !array.length || arguments.length < 2) {\n    return array\n  }\n  if (!scope) {\n    scope = {}\n  }\n  const evaluator = expressions.compile(unEscapeQuotes(predicateStr))\n  // predicateStr can refer to built-in properties _index, _index0, or _parent. These need to evaluate to the correct thing.\n  let lScope = Scope.pushList(array, scope.__scope, func.name)\n  const result = func.call(array, (item, index) => {\n    lScope = Scope.pushListItem(index, lScope, 'o' + index)\n    const subResult = evaluator(lScope._getScopeObject())\n    lScope = Scope.pop(lScope)\n    return subResult\n  })\n  lScope = Scope.pop(lScope)\n  return result\n}\n","const textTemplater = require('./text-templater')\nconst TextEvaluator = require('./text-evaluator')\nconst MetaEvaluator = require('./meta-evaluator')\nconst { AST } = require('./estree')\nconst base = require('./base-templater')\nconst EvaluationResult = require('./eval-result')\nexports.Engine = base\nexports.EvaluationResult = EvaluationResult\n\nvar compiledTemplateCache = new Map()\n\nexports.extractLogic = function (template, bIncludeListPunctuation = true) {\n  // returns a 'logic tree' for this template -- a filtered, optimized AST representing the logical structure of the template\n  return base.buildLogicTree(textTemplater.parseTemplate(template, true, bIncludeListPunctuation)) // note: parseTemplate uses caching for performance\n}\n\nexports.compileText = function (template) {\n  // returns curried function that will assemble the text template (given the data context as input)\n  // (this method currently throws if the template contains an error!)\n  const contentArray = textTemplater.parseTemplate(template) // uses caching -- will return same content array for same template string\n  let func = compiledTemplateCache.get(contentArray)\n  if (!func) {\n    func = (context, locals) => new EvaluationResult((new TextEvaluator(context, locals)).assemble(contentArray), [], []) // TODO: populate the missing & errors collections!!\n    compiledTemplateCache.set(contentArray, func)\n  }\n  return func\n}\n\nexports.assembleText = function (template, context, locals) {\n  // non-curried version of assembly: pass in a template AND a context\n  try {\n    const contentArray = textTemplater.parseTemplate(template)\n    const value = (new TextEvaluator(context, locals)).assemble(contentArray)\n    return new EvaluationResult(value, [], []) // TODO: populate the missing & errors collections!!\n  } catch (err) {\n    return new EvaluationResult(null, [], [err.message]) // TODO: populate the missing & errors collections!!\n  }\n}\n\nexports.assembleMeta = function (metaTemplate, context, locals) {\n  try {\n    const contentArray = textTemplater.parseTemplate(metaTemplate, true, false)\n    const nodes = (new MetaEvaluator(context, locals)).assemble(contentArray)\n    const program = {\n      type: AST.Program,\n      body: nodes.filter(n => !n.error)\n    }\n    return new EvaluationResult(program, [], nodes.filter(n => n.error)) // TODO: populate the missing collection!!\n  } catch (err) {\n    return new EvaluationResult(null, [], [err.message])\n  }\n}\n\nexports.FieldTypes = require('./fieldtypes')\nexports.Scope = require('./scope')","'use strict'\n\nconst Scope = require('./scope')\nconst OD = require('./fieldtypes')\nconst base = require('./base-templater')\n\nclass MetaEvaluator {\n  constructor (context, locals = null) {\n    if (context) {\n      this.contextStack = Scope.pushObject(context)\n    }\n    if (locals) {\n      this.contextStack = Scope.pushObject(locals, this.contextStack)\n    }\n  }\n\n  assemble (contentArray) {\n    const result = contentArray.map(contentItem => ContentReplacementTransform(contentItem, this.contextStack))\n    this.contextStack = Scope.pop(this.contextStack)\n    return FlatSingle(result)\n  }\n}\nmodule.exports = MetaEvaluator\n\nfunction ContentReplacementTransform (contentItem, contextStack) {\n  if (!contentItem || (typeof contentItem === 'string')) { return }\n  if (typeof contentItem !== 'object') { throw new Error(`Unexpected content '${contentItem}'`) }\n  const frame = contextStack // .peek()\n  switch (contentItem.type) {\n    case OD.Content:\n      try {\n        const evaluator = base.compileExpr(contentItem.expr)\n        return frame._deferredEvaluation(evaluator)\n      } catch (err) {\n        return CreateContextErrorMessage(err.message)\n      }\n\n    case OD.List: {\n      let iterable\n      try {\n        const evaluator = base.compileExpr(contentItem.expr)\n        iterable = frame._evaluate(evaluator) // we need to make sure this is memoized to avoid unnecessary re-evaluation\n      } catch (err) {\n        return CreateContextErrorMessage(err.message)\n      }\n      contextStack = Scope.pushList(iterable, contextStack, contentItem.expr)\n      const allContent = contextStack._indices.map(index => {\n        contextStack = Scope.pushListItem(index, contextStack, 'o' + index)\n        const listItemContent = contentItem.contentArray.map(listContentItem => ContentReplacementTransform(listContentItem, contextStack))\n        contextStack = Scope.pop(contextStack)\n        return FlatSingle(listItemContent)\n      })\n      contextStack = Scope.pop(contextStack)\n      return FlatSingle(allContent)\n    }\n\n    case OD.If:\n    case OD.ElseIf: {\n      let bValue\n      try {\n        if (frame._scopeType != Scope.OBJECT) {\n          throw new Error(`Internal error: cannot define a condition directly in a ${frame._scopeType} context`)\n        }\n        const evaluator = base.compileExpr(contentItem.expr)\n        const value = frame._evaluate(evaluator) // we need to make sure this is memoized to avoid unnecessary re-evaluation\n        bValue = Scope.isTruthy(value)\n      } catch (err) {\n        return CreateContextErrorMessage(err.message)\n      }\n      if (bValue) {\n        const content = contentItem.contentArray\n          .filter(item => (typeof item !== 'object') || (item == null) || (item.type != OD.ElseIf && item.type != OD.Else))\n          .map(conditionalContentItem => ContentReplacementTransform(conditionalContentItem, contextStack))\n        return FlatSingle(content)\n      }\n      const elseCond = contentItem.contentArray.find(item => (typeof item === 'object' && item != null && (item.type == OD.ElseIf || item.type == OD.Else)))\n      if (elseCond) {\n        if (elseCond.type == OD.ElseIf) { return ContentReplacementTransform(elseCond, contextStack) }\n        // else\n        const content = elseCond.contentArray\n          .map(conditionalContentItem => ContentReplacementTransform(conditionalContentItem, contextStack))\n        return FlatSingle(content)\n      }\n    }\n      break\n  }\n}\n\nfunction FlatSingle (arr) {\n  return [].concat(...arr).filter(Boolean)\n}\n\nfunction CreateContextErrorMessage (message) {\n  return { error: 'Evaluation Error: ' + message }\n}\n","'use strict'\nconst { AST } = require('./estree')\n\nconst scopeChainHandler = {\n  get: function(target, prop) {\n    if (prop === '__scope') {\n      return target\n    }\n    let current = target\n    while (current) {\n      if (prop in current) {\n        return current[prop]\n      } else if (prop in current._data) {\n        return current._data[prop]\n      }\n      current = current._parent || current._parentScope\n    }\n  }\n}\n\nclass Scope {\n  constructor (scopeType, scopeLabel, data = null, parent = null) {\n    this._scopeType = scopeType\n    this._label = scopeLabel\n    this._parentScope = parent\n    this._dataType = typeof data\n    switch (this._dataType) {\n      case 'object':\n        this._data = data\n        break\n      case 'string':\n        this._data = new String(data)\n        break\n      case 'number':\n        this._data = new Number(data)\n        break\n      case 'boolean': \n        this._data = new Boolean(data)\n        break\n      default:\n        this._data = data\n    }\n  }\n\n  [Symbol.toPrimitive](hint) {\n    if (!this._data) return undefined\n    switch(this._dataType) {\n      case 'string':\n      case 'number':\n      case 'boolean':\n        return this._data.valueOf()\n      default:\n        if (hint === 'string') return this._data.toString()\n        if (hint === 'number') return Number(this._data)\n        // else\n        return Boolean(this._data)\n    }\n  }\n\n  _getScopeObject() {\n    return new Proxy(this, scopeChainHandler)\n  }\n\n  _evaluate (compiledExpr) {\n    if (compiledExpr.ast.type === AST.ThisExpression) { // special case\n      return this._data\n    } // else\n    return compiledExpr(this._getScopeObject())\n  }\n  \n  _deferredEvaluation (compiledExpr) {\n    return {\n      type: AST.ExpressionStatement,\n      expression: compiledExpr.ast,\n      text: compiledExpr.normalized,\n      data: this.data\n    }\n  }\n\n  static empty(scope) {\n    return (!scope || !scope._parentScope)\n  }\n\n  static pop (scope) {\n    if (Scope.empty(scope)) return null\n    const parent = scope._parentScope\n    scope._parentScope = null\n    return parent\n  }\n\n  static pushObject (data, parent = null, label = '') {\n    return new Scope(Scope.OBJECT, label || (parent ? label : '_odx'), data, parent)\n  }\n\n  static pushList (iterable, parent, label) {\n    return new ListScope(label, iterable, parent)\n  }\n\n  static pushListItem (index0, parentList, label) {\n    return new ItemScope(label, index0, parentList)\n  }\n\n  static isTruthy (value) {\n    let bValue\n    if (value && Scope.isIterable(value)) {\n      // checking if a list is empty or not\n      if (!Scope.isArray(value)) {\n        value = Array.from(value)\n      }\n      bValue = (value.length > 0) // for purposes of if fields in opendocx, we consider empty lists falsy!\n      // (unlike typical JavaScript, where any non-null array, even empty ones, are considered truthy)\n    } else {\n      bValue = Boolean(value)\n    }\n    return bValue\n  }\n\n  static isArray (obj) {\n    return Array.isArray(obj)\n  }\n\n  static isIterable (obj) {\n    // checks for null and undefined; also strings (though iterable) should not be iterable *contexts*\n    if (obj == null || typeof obj === 'string') {\n      return false\n    }\n    return typeof obj[Symbol.iterator] === 'function'\n  }\n}\nScope.OBJECT = 'Object'\nScope.LIST = 'List'\nmodule.exports = Scope\n\nclass ListScope extends Scope {\n  constructor (scopeLabel, iterable, parent) {\n    const array = iterable ? Array.from(iterable) : []\n    super(Scope.LIST, scopeLabel, array, parent)\n    this._indices = indices(array.length)\n    this._punc = iterable ? iterable.punc : null\n  }\n}\n\nclass ItemScope extends Scope {\n  constructor (scopeLabel, index0, parentList) {\n    if (!parentList || parentList._scopeType !== Scope.LIST) {\n      throw new Error('ItemScope must be a child of ListScope')\n    }\n    super(Scope.OBJECT, scopeLabel, parentList._data[index0], parentList)\n    this._index0 = index0\n  }\n\n  get _index () {\n    return this._index0 + 1\n  }\n\n  get _parent () {\n    return new Proxy(this._parentScope._parentScope, scopeChainHandler)\n  }\n\n  get _punc () {\n    const index0 = this._index0\n    const lastItem = this._parentScope._data.length - 1\n    const punc = this._parentScope._punc\n    return punc                  // if punctuation was specified\n      ? (index0 == lastItem)       // if index0 is the last item\n        ? punc.suffix              // get the list suffix (if any)\n        : (index0 == lastItem - 1) // else if index0 is 2nd to last\n          ? index0 == 0            //    ... and ALSO first (meaning there are only 2!)\n            ? punc.only2           //        ... then get only2\n            : punc.last2           //        ... otherwise get last2\n          : punc.between           // otherwise just get regular 'between' punctuation\n      : ''                       // otherwise no punctuation\n  }\n}\n\nconst indices = (length) => new Array(length).fill(undefined).map((value, index) => index)\n","'use strict'\n\nconst Scope = require('./scope')\nconst OD = require('./fieldtypes')\nconst base = require('./base-templater')\n\nclass TextEvaluator {\n  constructor (context, locals = null) {\n    if (context) {\n      this.contextStack = Scope.pushObject(context)\n    }\n    if (locals) {\n      this.contextStack = Scope.pushObject(locals, this.contextStack)\n    }\n  }\n\n  assemble (contentArray) {\n    const text = contentArray.map(contentItem => ContentReplacementTransform(contentItem, this.contextStack)).join('')\n    this.contextStack = Scope.pop(this.contextStack)\n    return text\n  }\n}\nmodule.exports = TextEvaluator\n\nfunction ContentReplacementTransform (contentItem, contextStack) {\n  if (!contentItem) { return '' }\n  if (typeof contentItem === 'string') { return contentItem }\n  if (typeof contentItem !== 'object') { throw new Error(`Unexpected content '${contentItem}'`) }\n  const frame = contextStack // .peek()\n  switch (contentItem.type) {\n    case OD.Content:\n      try {\n        const evaluator = base.compileExpr(contentItem.expr) // these are cached so this should be fast\n        let value = frame._evaluate(evaluator) // we need to make sure this is memoized to avoid unnecessary re-evaluation\n        if (value === null || typeof value === 'undefined') {\n          value = '[' + contentItem.expr + ']' // missing value placeholder\n        }\n        return value\n      } catch (err) {\n        return CreateContextErrorMessage('EvaluationException: ' + err.message)\n      }\n    case OD.List: {\n      let iterable\n      try {\n        const evaluator = base.compileExpr(contentItem.expr) // these are cached so this should be fast\n        iterable = frame._evaluate(evaluator) // we need to make sure this is memoized to avoid unnecessary re-evaluation\n      } catch (err) {\n        return CreateContextErrorMessage('EvaluationException: ' + err.message)\n      }\n      contextStack = Scope.pushList(iterable, contextStack, contentItem.expr) // const indices = contextStack.pushList(contentItem.expr, iterable)\n      const allContent = contextStack._indices.map(index => {\n        contextStack = Scope.pushListItem(index, contextStack, 'o' + index) // contextStack.pushObject('o' + index, index)\n        const listItemContent = contentItem.contentArray.map(listContentItem => ContentReplacementTransform(listContentItem, contextStack))\n        contextStack = Scope.pop(contextStack) // contextStack.popObject()\n        return listItemContent.join('')\n      })\n      contextStack = Scope.pop(contextStack) // contextStack.popList()\n      return allContent.join('')\n    }\n    case OD.If:\n    case OD.ElseIf: {\n      let bValue\n      try {\n        if (frame._scopeType != Scope.OBJECT) {\n          throw new Error(`Internal error: cannot define a condition directly in a ${frame._scopeType} context`)\n        }\n        const evaluator = base.compileExpr(contentItem.expr) // these are cached so this should be fast\n        const value = frame._evaluate(evaluator) // we need to make sure this is memoized to avoid unnecessary re-evaluation\n        bValue = Scope.isTruthy(value)\n      } catch (err) {\n        return CreateContextErrorMessage('EvaluationException: ' + err.message)\n      }\n      if (bValue) {\n        const content = contentItem.contentArray\n          .filter(item => (typeof item !== 'object') || (item == null) || (item.type != OD.ElseIf && item.type != OD.Else))\n          .map(conditionalContentItem => ContentReplacementTransform(conditionalContentItem, contextStack))\n        return content.join('')\n      }\n      const elseCond = contentItem.contentArray.find(item => (typeof item === 'object' && item != null && (item.type == OD.ElseIf || item.type == OD.Else)))\n      if (elseCond) {\n        if (elseCond.type == OD.ElseIf) { return ContentReplacementTransform(elseCond, contextStack) }\n        // else\n        const content = elseCond.contentArray\n          .map(conditionalContentItem => ContentReplacementTransform(conditionalContentItem, contextStack))\n        return content.join('')\n      }\n      return ''\n    }\n  }\n}\n\nfunction CreateContextErrorMessage (message) {\n  return '*** ' + message + ' ***'\n}\n","/* eslint-disable no-prototype-builtins */\nconst base = require('./base-templater')\n\n/* parseTemplate parses a text template (passed in as a string)\n   into an object tree structure -- essentially a high-level AST for the template.\n\n   CRLF handling:\n   any field that's alone on a line of text (preceded by either a CRLF or the beginning of the string, and followed by a CRLF),\n   needs to (during parsing) \"consume\" the CRLF that follows it, to avoid unexpected lines in the assembled output.\n*/\nfunction parseTemplate (template, bIncludeExpressions = true, bIncludeListPunctuation = true) {\n  const templateCache = parseTemplate.cache\n  if (templateCache && templateCache.hasOwnProperty(template)) { return templateCache[template] }\n  // if any block-level paired fields are on a lines by themselves, remove the CR/LF following those fields\n  // (but leave block-level content fields alone)\n  const tweaked = template.replace(_blockFieldRE, _blockFieldReplacer)\n  const templateSplit = tweaked.split(_fieldRE) // TODO: improve this approach with something that captures & retains each field offset\n  let result = (templateSplit.length < 2) /* no fields */ ? [ template ] : base.parseContentArray(templateSplit, bIncludeExpressions, bIncludeListPunctuation)\n  if (templateCache) {\n    templateCache[template] = result\n  }\n  return result\n}\nparseTemplate.cache = {}\nexports.parseTemplate = parseTemplate\n\nconst _blockFieldReplacer = function (match, fieldText, eol, offset, string) {\n  var cleaned = `{[${fieldText}]}`\n  if (!fieldText.match(/^if|\\?|else|:|list|#|end|\\//)) {\n    cleaned += eol\n  }\n  return cleaned\n}\n//const _blockFieldRE = /(?<=\\n|\\r|^)\\{\\s*\\[([^{}]*?)\\]\\s*\\}(\\r\\n|\\n|\\r)/g // positive lookbehind breaks every browser but chrome! (as of mid 2019)\nconst _blockFieldRE = /^\\{\\s*\\[([^{}]*?)\\]\\s*\\}(\\r\\n|\\n|\\r)/gm\nconst _fieldRE = /\\{\\s*(\\[.*?\\])\\s*\\}/\nconst _fieldsRE = /\\{\\s*\\[(.*?)\\]\\s*\\}/g\n\n// const extractFields = function (contentArray) {\n//     return contentArray\n//         .filter(obj => obj != null && typeof obj == \"object\")\n//         .map(obj => {\n//             const newObj = { type: obj.type };\n//             if (typeof obj.expr == 'string')\n//                 newObj.expr = obj.expr;\n//             if (obj.exprAst)\n//                 newObj.exprAst = obj.exprAst;\n//             if (obj.contentArray && obj.contentArray.length > 0)\n//                 newObj.contentArray = extractFields(obj.contentArray);\n//             return newObj;\n//         });\n// }\n// exports.extractFields = extractFields;\n\n// new-and-improved parsing of text templates... not yet fully implemented :-(\nfunction parseText (template, bIncludeExpressions = true, bIncludeListPunctuation = true) {\n  let templateCache = parseText.cache\n  if (templateCache && templateCache.hasOwnProperty(template)) { return templateCache[template] }\n  // split template into lines (parallel to paragraphs in Word doc)\n  const lines = []\n  // scan fields in text, embedding metadata in each field about its line no, character offset & chunk no. Each line is now an array of content items, and each field has a L:C:K id.\n  for (const line of template.split('\\n')) {\n    const items = []\n    let match\n    while ((match = _fieldsRE.exec(line)) !== null) {\n      // todo: capture text (if any) prior to field\n      const lastEnd = items.length && items[items.length - 1].end\n      if (match.index > lastEnd) {\n        items.push(line.substring(lastEnd, match.index))\n      }\n      items.push({\n        content: match[1],\n        start: match.index,\n        end: _fieldsRE.lastIndex\n      })\n    }\n    if (items.length === 0) {\n      items.push(line)\n    } else {\n      const lastEnd = items[items.length - 1].end\n      if (line.length > lastEnd) {\n        items.push(line.substr(lastEnd))\n      }\n    }\n    lines.push(items)\n  }\n  // perform some validation on content items as we go: make sure ifs & lists are either in same line as their matching end fields, or on lines by themselves\n  // extract all the fields into one content array, in order, which we will pass to the base templater\n  const contentArray = []\n  lines.forEach((lineArray, lineIndex) => {\n    lineArray.forEach((item, itemIndex) => {\n      if (typeof item === 'object') {\n        item.id = `${lineIndex + 1}:${item.start}:${item.end}:${itemIndex}`\n        contentArray.push(item)\n      }\n    })\n  })\n  // the base templater only gets a list of fields, it doesn't know whether they're from text or DOCX or PDF etc.\n  let result = base.parseContentArray(contentArray, bIncludeExpressions, bIncludeListPunctuation)\n  if (templateCache) {\n    templateCache[template] = result\n  }\n  return result\n}\nparseText.cache = {}\nexports.parseText = parseText\n\nclass ParsedTextTemplate {\n  constructor (template, bIncludeExpressions = true, bIncludeListPunctuation = true) {\n    // split template into lines (parallel to paragraphs in Word doc)\n    const lines = []\n    // scan fields in text, embedding metadata in each field about its line no, character offset & chunk no. Each line is now an array of content items, and each field has a L:C:K id.\n    for (const line of template.split('\\n')) {\n      const items = []\n      let match\n      while ((match = _fieldsRE.exec(line)) !== null) {\n        // todo: capture text (if any) prior to field\n        const lastEnd = items.length && items[items.length - 1].end\n        if (match.index > lastEnd) {\n          items.push(line.substring(lastEnd, match.index))\n        }\n        items.push({\n          content: match[1],\n          start: match.index,\n          end: _fieldsRE.lastIndex\n        })\n      }\n      if (items.length === 0) {\n        items.push(line)\n      } else {\n        const lastEnd = items[items.length - 1].end\n        if (line.length > lastEnd) {\n          items.push(line.substr(lastEnd))\n        }\n      }\n      lines.push(items)\n    }\n    // perform some validation on content items as we go: make sure ifs & lists are either in same line as their matching end fields, or on lines by themselves\n    const errors = []\n    NormalizeRepeatAndConditional(lines, errors)\n    // extract all the fields into one content array, in order, which we will pass to the base templater\n    const contentArray = []\n    lines.forEach((items, lineIndex) => {\n      items.forEach((item, itemIndex) => {\n        if (typeof item === 'object') {\n          item.id = `${lineIndex + 1}:${item.start}:${item.end}:${itemIndex}`\n          contentArray.push(item)\n        }\n      })\n    })\n    // the base templater only gets a list of fields, it doesn't know whether they're from text or DOCX or PDF etc.\n    this.ast = base.parseContentArray(contentArray, bIncludeExpressions, bIncludeListPunctuation)\n  }\n}\n\nfunction NormalizeRepeatAndConditional (lines, errors) {\n  const repeatDepth = 0\n  const conditionalDepth = 0\n  lines.forEach(items => {\n    items.filter(item => typeof item === 'object').forEach(field => {\n\n    })\n  })\n  // foreach (var metadata in xDoc.Descendants().Where(d =>\n  //         d.Name == OD.List ||\n  //         d.Name == OD.EndList ||\n  //         d.Name == OD.If ||\n  //         d.Name == OD.ElseIf ||\n  //         d.Name == OD.Else ||\n  //         d.Name == OD.EndIf))\n  // {\n  //     if (metadata.Name == OD.List)\n  //     {\n  //         ++repeatDepth;\n  //         metadata.Add(new XAttribute(OD.Depth, repeatDepth));\n  //         continue;\n  //     }\n  //     if (metadata.Name == OD.EndList)\n  //     {\n  //         metadata.Add(new XAttribute(OD.Depth, repeatDepth));\n  //         --repeatDepth;\n  //         continue;\n  //     }\n  //     if (metadata.Name == OD.If)\n  //     {\n  //         ++conditionalDepth;\n  //         metadata.Add(new XAttribute(OD.Depth, conditionalDepth));\n  //         continue;\n  //     }\n  //     if (metadata.Name == OD.ElseIf)\n  //     {\n  //         metadata.Add(new XAttribute(OD.Depth, conditionalDepth));\n  //         continue;\n  //     }\n  //     if (metadata.Name == OD.Else)\n  //     {\n  //         metadata.Add(new XAttribute(OD.Depth, conditionalDepth));\n  //         continue;\n  //     }\n  //     if (metadata.Name == OD.EndIf)\n  //     {\n  //         metadata.Add(new XAttribute(OD.Depth, conditionalDepth));\n  //         --conditionalDepth;\n  //         continue;\n  //     }\n  // }\n}\n"],"sourceRoot":""}